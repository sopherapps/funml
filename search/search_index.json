{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FunML","text":"<p>A collection of utilities to help write python as though it were an ML-kind of functional language like OCaml</p>"},{"location":"#what-is-functional-programming","title":"What is Functional Programming","text":""},{"location":"#1-all-about-pure-functions","title":"1. All About Pure Functions","text":"<p>Pure functions are those with no side effects i.e. the output of the function is a function of the inputs only. Unpredictable things such as accessing the file system, the network, etc. or mutating the inputs are strictly avoided.</p> <p>This is what makes the code obvious to the reader of the code. There are no hidden modifications of function inputs or some delay waiting for a network or file system connection or an unexpected error from an attempted network connection.</p> <p>Of course, we need to access the file system or the network in useful programs. Usually, functional programs wrap such impure operations in obvious wrappers showing that they have side effect.</p> <p>For instance Ocaml supports some imperative language constructs specifically to handle this kind of real-life imperative operations.</p>"},{"location":"#2-programs-compose-functions-from-other-functions","title":"2. Programs Compose Functions From Other Functions","text":"<p>Programs are generated from composing multiple functions together.</p> <p>For instance:</p> <pre><code>add = lambda x, y: x+y \nadd70 = lambda x: add(x, 70)\nbasic_factorial = lambda x: 1 if x &lt;= 0 else x * basic_factorial(x-1)\n# tail recursive -- easier for compiler to optimise\naccum_factorial = lambda x, ac: ac if x &lt;= 0 else accum_factorial(x-1, x*ac)\nfactorial = lambda x: accum_factorial(x, 1)\n</code></pre>"},{"location":"#3-data-is-immutable","title":"3. Data is Immutable","text":"<p>In order to ensure functions do not mutate their inputs, the data used once initialized cannot be changed.</p>"},{"location":"#why-functional-programming","title":"Why Functional Programming","text":"<ol> <li>Writing programs in a functional-style is really, really intuitive.</li> <li>The automated tests one writes for a functional-style program end up being small</li> <li>Reading functional-style source code is easy because functions are obvious.</li> <li>Due to data being immutable, it is easy to make concurrent programs.    Erlang maximizes this advantage, together with a few other concepts to    make really huge concurrent programs.</li> </ol>"},{"location":"#notable-features-of-funml","title":"Notable Features of FunML","text":"<ol> <li>Immutable data structures like enums, records, lists</li> <li>Piping outputs of one function to another as inputs. That's how bigger functions are created from smaller ones.</li> <li>Pattern matching for declarative conditional control of flow instead of using 'if's</li> <li>Error handling using the <code>Result</code> monad, courtesy of rust.    Instead of using <code>try-except</code> all over the place, functions return     a <code>Result</code> which has the right data when successful and an exception if unsuccessful.     The result is then pattern-matched to retrieve the data or react to the exception.</li> <li>No <code>None</code>. Instead, we use the <code>Option</code> monad, courtesy of rust.    When an Option has data, it is <code>Option.SOME</code>, or else it is <code>Option.NONE</code>.     Pattern matching helps handle both scenarios.</li> </ol>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li>python 3.7+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install funml with your package manager</p> <pre><code>$ pip install funml\n\n---&gt; 100%\n</code></pre>"},{"location":"change-log/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"change-log/#unreleased","title":"[Unreleased]","text":""},{"location":"change-log/#0318-2023-03-20","title":"[0.3.18] - 2023-03-20","text":""},{"location":"change-log/#added","title":"Added","text":"<ul> <li>Add ability to construct IList from generator</li> </ul>"},{"location":"change-log/#changed","title":"Changed","text":""},{"location":"change-log/#fixed","title":"Fixed","text":""},{"location":"change-log/#0317-2023-03-17","title":"[0.3.17] - 2023-03-17","text":""},{"location":"change-log/#added_1","title":"Added","text":""},{"location":"change-log/#changed_1","title":"Changed","text":"<ul> <li>Added <code>IList</code> to the list of exports of the <code>funml</code> package</li> </ul>"},{"location":"change-log/#fixed_1","title":"Fixed","text":""},{"location":"change-log/#0316-2023-03-02","title":"[0.3.16] - 2023-03-02","text":""},{"location":"change-log/#added_2","title":"Added","text":"<ul> <li>Add the <code>get_annotations</code> class method to records so as to hide the potentially unevaluated <code>__annotations__</code></li> </ul>"},{"location":"change-log/#changed_2","title":"Changed","text":""},{"location":"change-log/#fixed_2","title":"Fixed","text":""},{"location":"change-log/#0315-2023-02-27","title":"[0.3.15] - 2023-02-27","text":""},{"location":"change-log/#added_3","title":"Added","text":"<ul> <li>Add repr to data types of Record, Enum and IList</li> </ul>"},{"location":"change-log/#changed_3","title":"Changed","text":""},{"location":"change-log/#fixed_3","title":"Fixed","text":"<ul> <li>Fix incomplete json parsing of records due to nested typing.ForwardRefs in field annotations.</li> </ul>"},{"location":"change-log/#0314-2023-02-27","title":"[0.3.14] - 2023-02-27","text":""},{"location":"change-log/#added_4","title":"Added","text":""},{"location":"change-log/#changed_4","title":"Changed","text":""},{"location":"change-log/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed incompatible JSON error produced wit to_json on enums that have no associated data or whose data is <code>str</code></li> </ul>"},{"location":"change-log/#0313-2023-02-25","title":"[0.3.13] - 2023-02-25","text":""},{"location":"change-log/#added_5","title":"Added","text":"<ul> <li>Added <code>to_json</code> and <code>from_json</code> builtin expressions</li> </ul>"},{"location":"change-log/#changed_5","title":"Changed","text":"<ul> <li>Changed <code>IList</code> to a generic subscriptable type just like <code>List</code> e.g. <code>IList[str]</code></li> </ul>"},{"location":"change-log/#fixed_5","title":"Fixed","text":"<ul> <li>Fixed how records load lazy annotations</li> </ul>"},{"location":"change-log/#0312-2023-02-23","title":"[0.3.12] - 2023-02-23","text":""},{"location":"change-log/#added_6","title":"Added","text":""},{"location":"change-log/#changed_6","title":"Changed","text":""},{"location":"change-log/#fixed_6","title":"Fixed","text":"<ul> <li>Fix TypeError: isinstance() arg 2 must be a type or tuple of types when records have Enum fields</li> </ul>"},{"location":"change-log/#0311-2023-02-21","title":"[0.3.11] - 2023-02-21","text":""},{"location":"change-log/#added_7","title":"Added","text":""},{"location":"change-log/#changed_7","title":"Changed","text":""},{"location":"change-log/#fixed_7","title":"Fixed","text":"<ul> <li>Fix TypeError: isinstance() argument 2 cannot be a parameterized generic in python 3.11</li> </ul>"},{"location":"change-log/#0310-2023-02-16","title":"[0.3.10] - 2023-02-16","text":""},{"location":"change-log/#added_8","title":"Added","text":""},{"location":"change-log/#changed_8","title":"Changed","text":""},{"location":"change-log/#fixed_8","title":"Fixed","text":"<ul> <li>Fix TypeError in records: isinstance() argument cannot be a parameterized generic</li> </ul>"},{"location":"change-log/#039-2023-02-16","title":"[0.3.9] - 2023-02-16","text":""},{"location":"change-log/#added_9","title":"Added","text":"<ul> <li>Extend types in record to handle \"...\" and \"bool | None\" etc.</li> </ul>"},{"location":"change-log/#changed_9","title":"Changed","text":""},{"location":"change-log/#fixed_9","title":"Fixed","text":""},{"location":"change-log/#038-2023-02-15","title":"[0.3.8] - 2023-02-15","text":""},{"location":"change-log/#added_10","title":"Added","text":"<ul> <li>Expose the <code>Record</code> type on the root <code>funml</code> package</li> </ul>"},{"location":"change-log/#changed_10","title":"Changed","text":""},{"location":"change-log/#fixed_10","title":"Fixed","text":""},{"location":"change-log/#037-2023-02-15","title":"[0.3.7] - 2023-02-15","text":""},{"location":"change-log/#added_11","title":"Added","text":"<ul> <li>Add <code>to_dict</code> to convert a record into a dictionary</li> </ul>"},{"location":"change-log/#changed_11","title":"Changed","text":""},{"location":"change-log/#fixed_11","title":"Fixed","text":""},{"location":"change-log/#036-2023-02-15","title":"[0.3.6] - 2023-02-15","text":""},{"location":"change-log/#added_12","title":"Added","text":""},{"location":"change-log/#changed_12","title":"Changed","text":"<ul> <li>Records can have fields with subscripted builtin types like <code>list[str]</code> thanks to <code>from __future__ import annotations</code>.</li> <li>Records can define default values</li> </ul>"},{"location":"change-log/#fixed_12","title":"Fixed","text":""},{"location":"change-log/#035-2023-02-13","title":"[0.3.5] - 2023-02-13","text":""},{"location":"change-log/#added_13","title":"Added","text":""},{"location":"change-log/#changed_13","title":"Changed","text":"<ul> <li>Remove typings of <code>Expression</code>, <code>Pipeline</code> and <code>Operation</code>.</li> </ul>"},{"location":"change-log/#fixed_13","title":"Fixed","text":""},{"location":"change-log/#034-2023-02-10","title":"[0.3.4] - 2023-02-10","text":""},{"location":"change-log/#added_14","title":"Added","text":""},{"location":"change-log/#changed_14","title":"Changed","text":"<ul> <li>Changed typings of <code>Expression</code>, <code>Pipeline</code> and <code>Operation</code> to be subscriptable like <code>Callable</code> is.</li> </ul>"},{"location":"change-log/#fixed_14","title":"Fixed","text":""},{"location":"change-log/#033-2023-02-09","title":"[0.3.3] - 2023-02-09","text":""},{"location":"change-log/#added_15","title":"Added","text":"<ul> <li>Add ability to curry functions i.e. transform functions with multiple args into functions with fewer args</li> </ul>"},{"location":"change-log/#changed_15","title":"Changed","text":""},{"location":"change-log/#fixed_15","title":"Fixed","text":""},{"location":"change-log/#032-2023-02-08","title":"[0.3.2] - 2023-02-08","text":""},{"location":"change-log/#added_16","title":"Added","text":""},{"location":"change-log/#changed_16","title":"Changed","text":"<ul> <li>Signature of <code>__rshift__</code> for <code>Pipeline</code> and <code>Expression</code> returns either a <code>Pipeline</code> or <code>Any</code> result of executing the   pipeline.</li> </ul>"},{"location":"change-log/#fixed_16","title":"Fixed","text":""},{"location":"change-log/#031-2023-02-07","title":"[0.3.1] - 2023-02-07","text":""},{"location":"change-log/#added_17","title":"Added","text":"<ul> <li>Added <code>AsyncPipeline</code> to handle the pipelines that have asynchronous routines</li> </ul>"},{"location":"change-log/#changed_17","title":"Changed","text":""},{"location":"change-log/#fixed_17","title":"Fixed","text":""},{"location":"change-log/#030-2023-01-30","title":"[0.3.0] - 2023-01-30","text":""},{"location":"change-log/#added_18","title":"Added","text":"<ul> <li>Added <code>Pipeline</code>'s to move all piping to them</li> </ul>"},{"location":"change-log/#changed_18","title":"Changed","text":"<ul> <li>Removed <code>Context</code></li> <li>Removed <code>let</code> and <code>Assignment</code>'s as these had side effects</li> </ul>"},{"location":"change-log/#fixed_18","title":"Fixed","text":"<ul> <li>Made expressions pure to avoid unexpected outcomes.</li> </ul>"},{"location":"change-log/#020-2023-01-28","title":"[0.2.0] - 2023-01-28","text":""},{"location":"change-log/#added_19","title":"Added","text":"<ul> <li>Result helpers: <code>if_ok</code>, <code>if_err</code>, <code>is_ok</code>, <code>is_err</code>.</li> <li>Option helpers: <code>if_some</code>, <code>if_none</code>, <code>is_some</code>, <code>is_none</code>.</li> <li>Sequence helpers: <code>imap</code>, <code>ifilter</code>, <code>ireduce</code>.</li> <li>Pipeline helper: <code>funml.execute()</code>.</li> </ul>"},{"location":"change-log/#changed_19","title":"Changed","text":"<ul> <li>Changed creation of records to use classes decorated with <code>record</code>.</li> <li>Changed creation of enums to use classes subclassed from <code>funml.Enum</code>.</li> <li>Removed <code>map</code> and <code>filter</code> methods of <code>IList</code>.</li> </ul>"},{"location":"change-log/#fixed_19","title":"Fixed","text":"<ul> <li>Fixed equality check of Result.ERR as originally Result.ERR(TypeError()) was not equal to Result.ERR(TypeError()).</li> </ul>"},{"location":"change-log/#001-2023-01-26","title":"[0.0.1] - 2023-01-26","text":""},{"location":"change-log/#added_20","title":"Added","text":"<ul> <li>Initial release</li> <li>pattern matching</li> <li>piping </li> <li>immutable lists, enums, and records</li> <li><code>Option</code> for handling potentially-None data</li> <li><code>Result</code> to return from procedures that may raise an exception</li> <li>mkdocs documentation</li> </ul>"},{"location":"change-log/#changed_20","title":"Changed","text":""},{"location":"change-log/#fixed_20","title":"Fixed","text":""},{"location":"reference/","title":"FunML","text":"<p>A collection of utilities to help write python as though it were an ML-kind of functional language like OCaml.</p> <p>Provides:</p> <ol> <li>Immutable data structures like enums, records, lists</li> <li>Piping outputs of one function to another as inputs. That's how bigger functions are created from smaller ones.</li> <li>Pattern matching for declarative conditional control of flow instead of using 'if's</li> <li>Error handling using the <code>Result</code> monad, courtesy of rust.    Instead of using <code>try-except</code> all over the place, functions return    a <code>Result</code> which has the right data when successful and an exception if unsuccessful.    The result is then pattern-matched to retrieve the data or react to the exception.</li> <li>No <code>None</code>. Instead, we use the <code>Option</code> monad, courtesy of rust.    When an Option has data, it is <code>Option.SOME</code>, or else it is <code>Option.NONE</code>.    Pattern matching helps handle both scenarios.</li> </ol>"},{"location":"reference/#funml.Enum","title":"<code>Enum</code>","text":"<p>         Bases: <code>types.MLType</code></p> <p>Enumerable type that can only be in a limited number of forms.</p> <p>Other enums are created by inheriting from this type. An enum can only be in a limited number of forms or variant and each variant can have some data associated with each instance.</p> <p>Variants are created by setting class attributes. The value of the class attributes should be the shape of the associated data or <code>None</code> if variant has no associated data.</p> <p>The pre-created types of <code>Option</code> and <code>Result</code> are both enums</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>got unexpected data type, different from the signature</p> Example <pre><code>import funml as ml\nfrom datetime import date\nclass Day(ml.Enum):\nMON = date\nTUE = date\nWED = date\nTHUR = date\nFRI = date\nSAT = date\nSUN = date\ndates =  [\ndate(200, 3, 4),\ndate(2009, 1, 16),\ndate(1993, 12, 29),\ndate(2004, 10, 13),\ndate(2020, 9, 5),\ndate(2004, 5, 7),\ndate(1228, 8, 18),\n]\nto_day_enum = lambda date_value: (\nml.match(date_value.weekday())\n.case(0, do=lambda: Day.MON(date_value))\n.case(1, do=lambda: Day.TUE(date_value))\n.case(2, do=lambda: Day.WED(date_value))\n.case(3, do=lambda: Day.THUR(date_value))\n.case(4, do=lambda: Day.FRI(date_value))\n.case(5, do=lambda: Day.SAT(date_value))\n.case(6, do=lambda: Day.SUN(date_value))\n)()\nday_enums_transform = ml.imap(to_day_enum)\nday_enums = day_enums_transform(dates)\nprint(day_enums)\n# prints [&lt;Day.TUE: datetime.date(200, 3, 4)&gt;, &lt;Day.FRI: datetime.date(2009, 1, 16)&gt;,        # &lt;Day.WED: datetime.date(1993, 12, 29)&gt;, &lt;Day.WED: datetime.date(2004, 10, 13)&gt;,         # &lt;Day.SAT: datetime.date(2020, 9, 5)&gt;, &lt;Day.FRI: datetime.date(2004, 5, 7)&gt;,         # &lt;Day.FRI: datetime.date(1228, 8, 18)&gt;]\n</code></pre> Source code in <code>funml/data/enum.py</code> <pre><code>class Enum(types.MLType):\n\"\"\"Enumerable type that can only be in a limited number of forms.\n    Other enums are created by inheriting from this type.\n    An enum can only be in a limited number of forms or variant and each variant\n    can have some data associated with each instance.\n    Variants are created by setting class attributes. The value of the class\n    attributes should be the shape of the associated data or `None` if variant has no\n    associated data.\n    The pre-created types of [`Option`][funml.Option] and [`Result`][funml.Result]\n    are both enums\n    Raises:\n        TypeError: got unexpected data type, different from the signature\n    Example:\n        ```python\n        import funml as ml\n        from datetime import date\n        class Day(ml.Enum):\n            MON = date\n            TUE = date\n            WED = date\n            THUR = date\n            FRI = date\n            SAT = date\n            SUN = date\n        dates =  [\n            date(200, 3, 4),\n            date(2009, 1, 16),\n            date(1993, 12, 29),\n            date(2004, 10, 13),\n            date(2020, 9, 5),\n            date(2004, 5, 7),\n            date(1228, 8, 18),\n        ]\n        to_day_enum = lambda date_value: (\n            ml.match(date_value.weekday())\n                .case(0, do=lambda: Day.MON(date_value))\n                .case(1, do=lambda: Day.TUE(date_value))\n                .case(2, do=lambda: Day.WED(date_value))\n                .case(3, do=lambda: Day.THUR(date_value))\n                .case(4, do=lambda: Day.FRI(date_value))\n                .case(5, do=lambda: Day.SAT(date_value))\n                .case(6, do=lambda: Day.SUN(date_value))\n        )()\n        day_enums_transform = ml.imap(to_day_enum)\n        day_enums = day_enums_transform(dates)\n        print(day_enums)\n        # prints [&lt;Day.TUE: datetime.date(200, 3, 4)&gt;, &lt;Day.FRI: datetime.date(2009, 1, 16)&gt;,\\\n        # &lt;Day.WED: datetime.date(1993, 12, 29)&gt;, &lt;Day.WED: datetime.date(2004, 10, 13)&gt;, \\\n        # &lt;Day.SAT: datetime.date(2020, 9, 5)&gt;, &lt;Day.FRI: datetime.date(2004, 5, 7)&gt;, \\\n        # &lt;Day.FRI: datetime.date(1228, 8, 18)&gt;]\n        ```\n    \"\"\"\nsignature: Optional[Union[Tuple[Type, ...], Dict[str, Type], Type]] = None\n_name: str = \"\"\ndef __init_subclass__(cls, **kwargs):\n\"\"\"Creating a new Enum\"\"\"\nslots = []\nfor k, v in _get_cls_attrs(cls).items():\ncls.__add_variant(k, v)\nslots.append(k)\ncls.__slots__ = slots\ndef __init__(self, *args: Union[Any, Dict[str, Any], int]):\nif isinstance(self.signature, tuple):\ndata = args\nelse:\ndata = args[0]\nif not _is_valid(data, self.signature):\nraise TypeError(\nf\"expected data type passed to be {self.signature}, got {data} from args: {args}\"\n)\nself._value = data\n@classmethod\ndef __add_variant(\ncls,\nname: str,\nshape: Optional[Union[Type, Tuple[Type, ...], Dict[str, Type]]] = None,\n) -&gt; Type[\"Enum\"]:\n\"\"\"Adds a given option to the enum.\n        This is a chainable method that can be used to add multiple options\n        to the same enum class.\n        Args:\n            name: the name of the option e.g. `ERR` for the [`Result`][funml.Result] enum\n            shape: the signature of the associated data\n        Returns:\n             the Enum class to which the option has been attached.\n        \"\"\"\ndotted_name = f\"{cls.__name__}.{name}\"\nsignature = shape\nif signature is None:\nopt_value = cls(name)\nelse:\n# each option is a subclass of this enum class\nopt_value = type(dotted_name, (cls,), {})\nopt_value._name = dotted_name\nopt_value.signature = signature\nsetattr(cls, name, opt_value)\nreturn cls\n@property\ndef value(self):\n\"\"\"The value associated with this Enum option, if any\"\"\"\nreturn self._value\n@property\ndef name(self):\n\"\"\"The name of this Enum\"\"\"\nreturn self._name\ndef generate_case(self, do: types.Operation) -&gt; Tuple[Callable, types.Expression]:\n\"\"\"See Base Class: [`MLType`][funml.types.MLType]\"\"\"\nop = lambda *args: do(*args)\nif self._value is not None:\nop = lambda arg: do(_get_enum_captured_value(arg))\nreturn self._is_like, types.Expression(types.Operation(func=op))\ndef _is_like(self, other) -&gt; bool:\n\"\"\"See Base Class: [`MLType`][funml.types.MLType]\"\"\"\nif not isinstance(other, Enum):\nreturn False\nreturn (\nself.__class__ == other.__class__\nand self._name == other._name\nand (self._value == other._value or _is_valid(other._value, self._value))\n)\ndef __eq__(self, other: \"Enum\"):\n\"\"\"Checks equality of the this enum and `other`.\n        Args:\n            other: the value to compare with current enum.\n        \"\"\"\nreturn (\nself.__class__ == other.__class__\nand self._name == other._name\nand utils.equals(self._value, other._value)\n)\ndef __str__(self):\n\"\"\"Generates a readable presentation of the enum.\"\"\"\nreturn f\"&lt;{self.name}: {self.value}&gt;\"\ndef __repr__(self):\nreturn f\"&lt;{self.name}: {self.value}&gt;\"\n</code></pre>"},{"location":"reference/#funml.data.enum.Enum.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of this Enum</p>"},{"location":"reference/#funml.data.enum.Enum.value","title":"<code>value</code>  <code>property</code>","text":"<p>The value associated with this Enum option, if any</p>"},{"location":"reference/#funml.data.enum.Enum.__add_variant","title":"<code>__add_variant(name, shape=None)</code>  <code>classmethod</code>","text":"<p>Adds a given option to the enum.</p> <p>This is a chainable method that can be used to add multiple options to the same enum class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the option e.g. <code>ERR</code> for the <code>Result</code> enum</p> required <code>shape</code> <code>Optional[Union[Type, Tuple[Type, ...], Dict[str, Type]]]</code> <p>the signature of the associated data</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[Enum]</code> <p>the Enum class to which the option has been attached.</p> Source code in <code>funml/data/enum.py</code> <pre><code>@classmethod\ndef __add_variant(\ncls,\nname: str,\nshape: Optional[Union[Type, Tuple[Type, ...], Dict[str, Type]]] = None,\n) -&gt; Type[\"Enum\"]:\n\"\"\"Adds a given option to the enum.\n    This is a chainable method that can be used to add multiple options\n    to the same enum class.\n    Args:\n        name: the name of the option e.g. `ERR` for the [`Result`][funml.Result] enum\n        shape: the signature of the associated data\n    Returns:\n         the Enum class to which the option has been attached.\n    \"\"\"\ndotted_name = f\"{cls.__name__}.{name}\"\nsignature = shape\nif signature is None:\nopt_value = cls(name)\nelse:\n# each option is a subclass of this enum class\nopt_value = type(dotted_name, (cls,), {})\nopt_value._name = dotted_name\nopt_value.signature = signature\nsetattr(cls, name, opt_value)\nreturn cls\n</code></pre>"},{"location":"reference/#funml.data.enum.Enum.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Checks equality of the this enum and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Enum</code> <p>the value to compare with current enum.</p> required Source code in <code>funml/data/enum.py</code> <pre><code>def __eq__(self, other: \"Enum\"):\n\"\"\"Checks equality of the this enum and `other`.\n    Args:\n        other: the value to compare with current enum.\n    \"\"\"\nreturn (\nself.__class__ == other.__class__\nand self._name == other._name\nand utils.equals(self._value, other._value)\n)\n</code></pre>"},{"location":"reference/#funml.data.enum.Enum.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Creating a new Enum</p> Source code in <code>funml/data/enum.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n\"\"\"Creating a new Enum\"\"\"\nslots = []\nfor k, v in _get_cls_attrs(cls).items():\ncls.__add_variant(k, v)\nslots.append(k)\ncls.__slots__ = slots\n</code></pre>"},{"location":"reference/#funml.data.enum.Enum.__str__","title":"<code>__str__()</code>","text":"<p>Generates a readable presentation of the enum.</p> Source code in <code>funml/data/enum.py</code> <pre><code>def __str__(self):\n\"\"\"Generates a readable presentation of the enum.\"\"\"\nreturn f\"&lt;{self.name}: {self.value}&gt;\"\n</code></pre>"},{"location":"reference/#funml.data.enum.Enum._is_like","title":"<code>_is_like(other)</code>","text":"<p>See Base Class: <code>MLType</code></p> Source code in <code>funml/data/enum.py</code> <pre><code>def _is_like(self, other) -&gt; bool:\n\"\"\"See Base Class: [`MLType`][funml.types.MLType]\"\"\"\nif not isinstance(other, Enum):\nreturn False\nreturn (\nself.__class__ == other.__class__\nand self._name == other._name\nand (self._value == other._value or _is_valid(other._value, self._value))\n)\n</code></pre>"},{"location":"reference/#funml.data.enum.Enum.generate_case","title":"<code>generate_case(do)</code>","text":"<p>See Base Class: <code>MLType</code></p> Source code in <code>funml/data/enum.py</code> <pre><code>def generate_case(self, do: types.Operation) -&gt; Tuple[Callable, types.Expression]:\n\"\"\"See Base Class: [`MLType`][funml.types.MLType]\"\"\"\nop = lambda *args: do(*args)\nif self._value is not None:\nop = lambda arg: do(_get_enum_captured_value(arg))\nreturn self._is_like, types.Expression(types.Operation(func=op))\n</code></pre>"},{"location":"reference/#funml.IList","title":"<code>IList</code>","text":"<p>         Bases: <code>types.MLType</code>, <code>Generic[T]</code></p> <p>An immutable list of items of any type.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>T</code> <p>the items to be included in the list.</p> <code>()</code> Source code in <code>funml/data/lists.py</code> <pre><code>class IList(types.MLType, Generic[T]):\n\"\"\"An immutable list of items of any type.\n    Args:\n        args: the items to be included in the list.\n    \"\"\"\ndef __init__(self, *args: T):\nself.__size: Optional[int] = None\nself.__capture_start: Optional[int] = None\nself.__capture_tail_len: int = 0\nself.__pre_capture: Optional[List[T]] = None\nself.__post_capture: Optional[List[T]] = None\nself.__list: Optional[List[T]] = None\nself._head: Optional[\"_Node\"] = None\nargs = _eval_generator_args(args)\nself.__set_size_from_args(args)\nself.__initialize_from_tuple(args)\n@property\ndef head(self) -&gt; T:\n\"\"\"The first item in the list.\"\"\"\nreturn self._head.value\n@property\ndef tail(self) -&gt; \"IList[T]\":\n\"\"\"A new slice of the list containing all items except the first.\"\"\"\nreturn IList.__from_node(self._head.next)\ndef generate_case(self, do: types.Operation):\n\"\"\"See Base class: [`MLType`][funml.types.MLType]\"\"\"\nstart = 0 if self.__capture_start is None else self.__capture_start\ntail_len = self.__capture_tail_len\ndef op(arg):\narg_slice = arg[start : (len(arg) - tail_len)]\nreturn do(arg_slice)\nreturn self._is_like, types.Expression(types.Operation(func=op))\ndef _is_like(self, other: Any) -&gt; bool:\n\"\"\"See Base Class: [`MLType`][funml.types.MLType]\"\"\"\nif not isinstance(other, IList):\nreturn False\nif self._size &gt; other._size:\nreturn False\nif self.__capture_start is None:\nreturn self == other\npre_capture = other._self_list[: self.__capture_start]\npost_capture = other._self_list[(len(other) - self.__capture_tail_len) :]\nreturn _lists_match(\nschema=self._pre_capture, actual=pre_capture\n) and _lists_match(schema=self._post_capture, actual=post_capture)\n@property\ndef _size(self) -&gt; int:\n\"\"\"The number of items in the list.\"\"\"\nif self.__size is None:\nself.__size = len(self._self_list)\nreturn self.__size\n@property\ndef _self_list(self) -&gt; List[T]:\n\"\"\"A cache of the native list that corresponds to this list.\"\"\"\nif self.__list is None:\nself.__list = list(self.__iter__())\nreturn self.__list\n@property\ndef _pre_capture(self) -&gt; List[T]:\n\"\"\"A slice of the list pattern before the section to be captured when matching.\"\"\"\nif self.__pre_capture is None and self.__capture_start is not None:\nself.__pre_capture = self._self_list[: self.__capture_start]\nreturn self.__pre_capture\n@property\ndef _post_capture(self) -&gt; List[T]:\n\"\"\"A slice of the list pattern after the section to be captured when matching.\"\"\"\nif self.__post_capture is None:\nself.__post_capture = self._self_list[\n(self._size - self.__capture_tail_len) :\n]\nreturn self.__post_capture\n@classmethod\ndef __from_node(cls, head: \"_Node[T]\") -&gt; \"IList[T]\":\n\"\"\"Generates a slice of the old IList given one node of that list.\n        In this case, the new list shares the same memory as the old list\n        so don't use this in scenarios where immutable lists are needed.\n        Args:\n            head: the node from which the new list is to start from.\n        Returns:\n            A new list that shares memory with the old list. **NOTE: This is not immutable. Don't use it**.\n        \"\"\"\ni_list = IList()\ni_list._head = head\nreturn i_list\ndef __set_size_from_args(self, args: Tuple[T]):\n\"\"\"Updates the size of this list basing on the args passed.\n        Args:\n            args: the items to be put in this list.\n        \"\"\"\nargs_len = len(args)\nif args_len &gt; 0:\nself.__size = args_len\ndef __initialize_from_tuple(self, args: Tuple[T]):\n\"\"\"Initializes the list using items passed to it as a tuple.\n        Initializes the current IList, generating nodes corresponding to the args passed\n        and setting any capture sections if `...` is found.\n        Args:\n            args: the items to include in the list\n        \"\"\"\nprev: Optional[_Node] = None\nfor i, v in enumerate(reversed(args)):\nnode = _Node(_data=v, _next=prev)\nprev = node\nif v is ...:\nself.__capture_start = self._size - i - 1\nself.__capture_tail_len = i\nself._head: Optional[\"_Node\"] = prev\ndef __len__(self):\n\"\"\"Computes the length of the list.\"\"\"\nreturn self._size\ndef __iter__(self):\n\"\"\"Makes the list an iterable.\"\"\"\nif self._head is None:\nreturn\nyield self._head.value\ncurr = self._head.next\nwhile curr is not None:\nyield curr.value\ncurr = curr.next\ndef __add__(self, other: \"IList[T]\") -&gt; \"IList[T]\":\n\"\"\"Creates a new list with the current list and the `other` list merged.\n        Args:\n            other: the list to be appended to current list when creating new merged list.\n        Returns:\n            A new list which is a combination of the current list and the `other` list.\n        Raises:\n            TypeError: other is not an `IList`\n        \"\"\"\nif not isinstance(other, IList):\nraise TypeError(\nf\"add operation requires value to be of type IList, not {type(other)}\"\n)\nreturn IList(*self, *other)\ndef __getitem__(self, item: Union[slice, int]) -&gt; Union[\"IList[T]\", Any]:\n\"\"\"Makes this list subscriptable and sliceable.\n        Args:\n            item: the index or slice to return.\n        Returns:\n            An `IList` if `index` was a slice or an item in the list if index was an integer.\n        Raises:\n            IndexError: if `item` is out of range of the list.\n        \"\"\"\nif isinstance(item, slice):\nreturn IList(*self._self_list[item])\nreturn self._self_list[item]\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Checks equality of the this list and `other`.\n        Args:\n            other: the value to compare with current list.\n        \"\"\"\nreturn utils.equals(self._self_list, other._self_list)\ndef __str__(self):\n\"\"\"Generates a readable presentation of the list.\"\"\"\nmap_to_str = imap(str)\nreturn f\"[{', '.join(map_to_str(self))}]\"\ndef __repr__(self):\nmap_to_str = imap(str)\nreturn f\"IList({', '.join(map_to_str(self))})\"\n</code></pre>"},{"location":"reference/#funml.data.lists.IList._post_capture","title":"<code>_post_capture: List[T]</code>  <code>property</code>","text":"<p>A slice of the list pattern after the section to be captured when matching.</p>"},{"location":"reference/#funml.data.lists.IList._pre_capture","title":"<code>_pre_capture: List[T]</code>  <code>property</code>","text":"<p>A slice of the list pattern before the section to be captured when matching.</p>"},{"location":"reference/#funml.data.lists.IList._self_list","title":"<code>_self_list: List[T]</code>  <code>property</code>","text":"<p>A cache of the native list that corresponds to this list.</p>"},{"location":"reference/#funml.data.lists.IList._size","title":"<code>_size: int</code>  <code>property</code>","text":"<p>The number of items in the list.</p>"},{"location":"reference/#funml.data.lists.IList.head","title":"<code>head: T</code>  <code>property</code>","text":"<p>The first item in the list.</p>"},{"location":"reference/#funml.data.lists.IList.tail","title":"<code>tail: IList[T]</code>  <code>property</code>","text":"<p>A new slice of the list containing all items except the first.</p>"},{"location":"reference/#funml.data.lists.IList.__add__","title":"<code>__add__(other)</code>","text":"<p>Creates a new list with the current list and the <code>other</code> list merged.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IList[T]</code> <p>the list to be appended to current list when creating new merged list.</p> required <p>Returns:</p> Type Description <code>IList[T]</code> <p>A new list which is a combination of the current list and the <code>other</code> list.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>other is not an <code>IList</code></p> Source code in <code>funml/data/lists.py</code> <pre><code>def __add__(self, other: \"IList[T]\") -&gt; \"IList[T]\":\n\"\"\"Creates a new list with the current list and the `other` list merged.\n    Args:\n        other: the list to be appended to current list when creating new merged list.\n    Returns:\n        A new list which is a combination of the current list and the `other` list.\n    Raises:\n        TypeError: other is not an `IList`\n    \"\"\"\nif not isinstance(other, IList):\nraise TypeError(\nf\"add operation requires value to be of type IList, not {type(other)}\"\n)\nreturn IList(*self, *other)\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Checks equality of the this list and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>the value to compare with current list.</p> required Source code in <code>funml/data/lists.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Checks equality of the this list and `other`.\n    Args:\n        other: the value to compare with current list.\n    \"\"\"\nreturn utils.equals(self._self_list, other._self_list)\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__from_node","title":"<code>__from_node(head)</code>  <code>classmethod</code>","text":"<p>Generates a slice of the old IList given one node of that list.</p> <p>In this case, the new list shares the same memory as the old list so don't use this in scenarios where immutable lists are needed.</p> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>_Node[T]</code> <p>the node from which the new list is to start from.</p> required <p>Returns:</p> Type Description <code>IList[T]</code> <p>A new list that shares memory with the old list. NOTE: This is not immutable. Don't use it.</p> Source code in <code>funml/data/lists.py</code> <pre><code>@classmethod\ndef __from_node(cls, head: \"_Node[T]\") -&gt; \"IList[T]\":\n\"\"\"Generates a slice of the old IList given one node of that list.\n    In this case, the new list shares the same memory as the old list\n    so don't use this in scenarios where immutable lists are needed.\n    Args:\n        head: the node from which the new list is to start from.\n    Returns:\n        A new list that shares memory with the old list. **NOTE: This is not immutable. Don't use it**.\n    \"\"\"\ni_list = IList()\ni_list._head = head\nreturn i_list\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Makes this list subscriptable and sliceable.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[slice, int]</code> <p>the index or slice to return.</p> required <p>Returns:</p> Type Description <code>Union[IList[T], Any]</code> <p>An <code>IList</code> if <code>index</code> was a slice or an item in the list if index was an integer.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if <code>item</code> is out of range of the list.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def __getitem__(self, item: Union[slice, int]) -&gt; Union[\"IList[T]\", Any]:\n\"\"\"Makes this list subscriptable and sliceable.\n    Args:\n        item: the index or slice to return.\n    Returns:\n        An `IList` if `index` was a slice or an item in the list if index was an integer.\n    Raises:\n        IndexError: if `item` is out of range of the list.\n    \"\"\"\nif isinstance(item, slice):\nreturn IList(*self._self_list[item])\nreturn self._self_list[item]\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__initialize_from_tuple","title":"<code>__initialize_from_tuple(args)</code>","text":"<p>Initializes the list using items passed to it as a tuple.</p> <p>Initializes the current IList, generating nodes corresponding to the args passed and setting any capture sections if <code>...</code> is found.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Tuple[T]</code> <p>the items to include in the list</p> required Source code in <code>funml/data/lists.py</code> <pre><code>def __initialize_from_tuple(self, args: Tuple[T]):\n\"\"\"Initializes the list using items passed to it as a tuple.\n    Initializes the current IList, generating nodes corresponding to the args passed\n    and setting any capture sections if `...` is found.\n    Args:\n        args: the items to include in the list\n    \"\"\"\nprev: Optional[_Node] = None\nfor i, v in enumerate(reversed(args)):\nnode = _Node(_data=v, _next=prev)\nprev = node\nif v is ...:\nself.__capture_start = self._size - i - 1\nself.__capture_tail_len = i\nself._head: Optional[\"_Node\"] = prev\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__iter__","title":"<code>__iter__()</code>","text":"<p>Makes the list an iterable.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def __iter__(self):\n\"\"\"Makes the list an iterable.\"\"\"\nif self._head is None:\nreturn\nyield self._head.value\ncurr = self._head.next\nwhile curr is not None:\nyield curr.value\ncurr = curr.next\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__len__","title":"<code>__len__()</code>","text":"<p>Computes the length of the list.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def __len__(self):\n\"\"\"Computes the length of the list.\"\"\"\nreturn self._size\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__set_size_from_args","title":"<code>__set_size_from_args(args)</code>","text":"<p>Updates the size of this list basing on the args passed.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Tuple[T]</code> <p>the items to be put in this list.</p> required Source code in <code>funml/data/lists.py</code> <pre><code>def __set_size_from_args(self, args: Tuple[T]):\n\"\"\"Updates the size of this list basing on the args passed.\n    Args:\n        args: the items to be put in this list.\n    \"\"\"\nargs_len = len(args)\nif args_len &gt; 0:\nself.__size = args_len\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.__str__","title":"<code>__str__()</code>","text":"<p>Generates a readable presentation of the list.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def __str__(self):\n\"\"\"Generates a readable presentation of the list.\"\"\"\nmap_to_str = imap(str)\nreturn f\"[{', '.join(map_to_str(self))}]\"\n</code></pre>"},{"location":"reference/#funml.data.lists.IList._is_like","title":"<code>_is_like(other)</code>","text":"<p>See Base Class: <code>MLType</code></p> Source code in <code>funml/data/lists.py</code> <pre><code>def _is_like(self, other: Any) -&gt; bool:\n\"\"\"See Base Class: [`MLType`][funml.types.MLType]\"\"\"\nif not isinstance(other, IList):\nreturn False\nif self._size &gt; other._size:\nreturn False\nif self.__capture_start is None:\nreturn self == other\npre_capture = other._self_list[: self.__capture_start]\npost_capture = other._self_list[(len(other) - self.__capture_tail_len) :]\nreturn _lists_match(\nschema=self._pre_capture, actual=pre_capture\n) and _lists_match(schema=self._post_capture, actual=post_capture)\n</code></pre>"},{"location":"reference/#funml.data.lists.IList.generate_case","title":"<code>generate_case(do)</code>","text":"<p>See Base class: <code>MLType</code></p> Source code in <code>funml/data/lists.py</code> <pre><code>def generate_case(self, do: types.Operation):\n\"\"\"See Base class: [`MLType`][funml.types.MLType]\"\"\"\nstart = 0 if self.__capture_start is None else self.__capture_start\ntail_len = self.__capture_tail_len\ndef op(arg):\narg_slice = arg[start : (len(arg) - tail_len)]\nreturn do(arg_slice)\nreturn self._is_like, types.Expression(types.Operation(func=op))\n</code></pre>"},{"location":"reference/#funml.Option","title":"<code>Option</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents a value that is potentially None</p> Variants <ul> <li>SOME: when an actual value exists</li> <li>NONE: when there is no value</li> </ul> Example Usage <pre><code>import funml as ml\nfrom typing import Any\nb = ml.Option.SOME(6)\na = ml.Option.NONE\nextract_option = (ml.match()\n.case(ml.Option.SOME(Any), do=lambda v: v)\n.case(ml.Option.NONE, do=lambda: \"nothing found\"))\nextract_option(b)\n# returns 6\nextract_option(a)\n# returns 'nothing found'\n</code></pre> Source code in <code>funml/data/monads.py</code> <pre><code>class Option(Enum):\n\"\"\"Represents a value that is potentially None\n    Variants:\n        - SOME: when an actual value exists\n        - NONE: when there is no value\n    Example Usage:\n        ```python\n        import funml as ml\n        from typing import Any\n        b = ml.Option.SOME(6)\n        a = ml.Option.NONE\n        extract_option = (ml.match()\n                .case(ml.Option.SOME(Any), do=lambda v: v)\n                .case(ml.Option.NONE, do=lambda: \"nothing found\"))\n        extract_option(b)\n        # returns 6\n        extract_option(a)\n        # returns 'nothing found'\n        ```\n    \"\"\"\nNONE = None\nSOME = Any\n</code></pre>"},{"location":"reference/#funml.Result","title":"<code>Result</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents a value that is potentially an exception</p> Variants <ul> <li>ERR: when an exception is raised</li> <li>OK: when there is a real value</li> </ul> Example <pre><code>import funml as ml\nfrom typing import Any\nb = ml.Result.OK(60)\na = ml.Result.ERR(TypeError(\"some error\"))\nextract_result = (ml.match()\n.case(ml.Result.OK(Any), do=lambda v: v)\n.case(ml.Result.ERR(Exception), do=lambda v: str(v)))\nextract_result(b)\n# returns 60\nextract_result(a)\n# returns 'some error'\n</code></pre> Source code in <code>funml/data/monads.py</code> <pre><code>class Result(Enum):\n\"\"\"Represents a value that is potentially an exception\n    Variants:\n        - ERR: when an exception is raised\n        - OK: when there is a real value\n    Example:\n        ```python\n        import funml as ml\n        from typing import Any\n        b = ml.Result.OK(60)\n        a = ml.Result.ERR(TypeError(\"some error\"))\n        extract_result = (ml.match()\n                .case(ml.Result.OK(Any), do=lambda v: v)\n                .case(ml.Result.ERR(Exception), do=lambda v: str(v)))\n        extract_result(b)\n        # returns 60\n        extract_result(a)\n        # returns 'some error'\n        ```\n    \"\"\"\nERR = Exception\nOK = Any\n</code></pre>"},{"location":"reference/#funml.execute","title":"<code>execute(*args, **kwargs)</code>","text":"<p>Executes a pipeline returning its output.</p> <p>A pipeline will be executed the moment this expression is reached.</p> <p>Don't use <code>&gt;&gt;</code> after a call to execute as the pipeline would have already terminated.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>any arguments to run on the pipeline</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>any key-word arguments to run on the pipeline.</p> <code>{}</code> Example <pre><code>import funml as ml\nto_power_of = ml.val(lambda power, v: v**power)\ndivided_by = ml.val(lambda divisor, v: v / divisor)\noutput = ml.val(90) &gt;&gt; to_power_of(3) &gt;&gt; divided_by(90) &gt;&gt; divided_by(3) &gt;&gt; ml.execute()\n# prints 2700\n</code></pre> Source code in <code>funml/pipeline.py</code> <pre><code>def execute(*args: Any, **kwargs: Any) -&gt; ExecutionExpression:\n\"\"\"Executes a pipeline returning its output.\n    A pipeline will be executed the moment this expression is\n    reached.\n    Don't use `&gt;&gt;` after a call to execute as the pipeline\n    would have already terminated.\n    Args:\n        args: any arguments to run on the pipeline\n        kwargs: any key-word arguments to run on the pipeline.\n    Example:\n        ```python\n        import funml as ml\n        to_power_of = ml.val(lambda power, v: v**power)\n        divided_by = ml.val(lambda divisor, v: v / divisor)\n        output = ml.val(90) &gt;&gt; to_power_of(3) &gt;&gt; divided_by(90) &gt;&gt; divided_by(3) &gt;&gt; ml.execute()\n        # prints 2700\n        ```\n    \"\"\"\nreturn ExecutionExpression(*args, **kwargs)\n</code></pre>"},{"location":"reference/#funml.from_json","title":"<code>from_json(type_, value, strict=True)</code>","text":"<p>Converts a JSON string into the given type.</p> <p>If strict is True, an error is returned if the JSON string cannot be converted into the type, else if strict is False and an error occurs, the default python primitive is str, dict etc. is returned.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>Type[T]</code> <p>the typing annotation to which the JSON string is to be converted to</p> required <code>value</code> <code>str</code> <p>the JSON string</p> required <code>strict</code> <code>bool</code> <p>whether the JSON string should be strictly converted to the given type or left as the default primitive python objects</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>the instance got from the JSON string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>unable to deserialize JSON to given type</p> Example <pre><code>import funml as ml\n@ml.record\nclass Student:\nname: str\nfavorite_color: \"Color\"\n@ml.record\nclass Color:\nr: int\ng: int\nb: int\na: \"Alpha\"\nclass Alpha(ml.Enum):\nOPAQUE = None\nTRANSLUCENT = float\nitems = [\n(\nml.IList[Color],\n(\n\"[\"\n'{\"name\": \"John Doe\", \"favorite_color\": {\"r\": 8, \"g\": 4, \"b\": 78, \"a\": \"Alpha.OPAQUE: \\\"OPAQUE\\\"\"}}, '\n'{\"name\": \"Jane Doe\", \"favorite_color\": {\"r\": 55, \"g\": 40, \"b\": 9, \"a\": \"Alpha.TRANSLUCENT: 0.4\"}}'\n\"]\"\n)\n),\n(Color, '{\"r\": 55, \"g\": 40, \"b\": 9, \"a\": \"Alpha.TRANSLUCENT: 0.4\"}'),\n(Alpha, \"Alpha.TRANSLUCENT: 0.4\"),\n]\n# setting strict to False can allow any json string to be converted to a python object,\n# first attempting to convert it to the provided type, and if it fails,\n# the output of an ordinary json.loads call is returned.\n#\n# However, when strict is True, ValueError's will be raised\n# if the json string can't be converted into the given type\nstrict = True\nfor type_, item_json in items:\nitem = ml.from_json(type_=type_, value=item_json, strict=strict)\nprint(item)\n</code></pre> Source code in <code>funml/json.py</code> <pre><code>def from_json(type_: Type[T], value: str, strict: bool = True) -&gt; T:\n\"\"\"Converts a JSON string into the given type.\n    If strict is True, an error is returned if the JSON string cannot be converted into\n    the type, else if strict is False and an error occurs,\n    the default python primitive is str, dict etc.\n    is returned.\n    Args:\n        type_: the typing annotation to which the JSON string is to be converted to\n        value: the JSON string\n        strict: whether the JSON string should be strictly converted to the given type\n            or left as the default primitive python objects\n    Returns:\n        the instance got from the JSON string\n    Raises:\n        ValueError: unable to deserialize JSON to given type\n    Example:\n        ```python\n        import funml as ml\n        @ml.record\n        class Student:\n            name: str\n            favorite_color: \"Color\"\n        @ml.record\n        class Color:\n            r: int\n            g: int\n            b: int\n            a: \"Alpha\"\n        class Alpha(ml.Enum):\n            OPAQUE = None\n            TRANSLUCENT = float\n        items = [\n            (\n                ml.IList[Color],\n                (\n                \"[\"\n                '{\"name\": \"John Doe\", \"favorite_color\": {\"r\": 8, \"g\": 4, \"b\": 78, \"a\": \"Alpha.OPAQUE: \\\\\"OPAQUE\\\\\"\"}}, '\n                '{\"name\": \"Jane Doe\", \"favorite_color\": {\"r\": 55, \"g\": 40, \"b\": 9, \"a\": \"Alpha.TRANSLUCENT: 0.4\"}}'\n                \"]\"\n                )\n            ),\n            (Color, '{\"r\": 55, \"g\": 40, \"b\": 9, \"a\": \"Alpha.TRANSLUCENT: 0.4\"}'),\n            (Alpha, \"Alpha.TRANSLUCENT: 0.4\"),\n        ]\n        # setting strict to False can allow any json string to be converted to a python object,\n        # first attempting to convert it to the provided type, and if it fails,\n        # the output of an ordinary json.loads call is returned.\n        #\n        # However, when strict is True, ValueError's will be raised\n        # if the json string can't be converted into the given type\n        strict = True\n        for type_, item_json in items:\n            item = ml.from_json(type_=type_, value=item_json, strict=strict)\n            print(item)\n        ```\n    \"\"\"\nactual_type = extract_type(type_)\nframe = inspect.currentframe()\ntry:\n_globals = frame.f_back.f_globals\n_locals = frame.f_back.f_locals\nif issubclass(actual_type, Enum):\nreturn _enum_from_json(\nactual_type, value, strict, _globals=_globals, _locals=_locals\n)\nif issubclass(actual_type, Record):\nreturn _record_from_json(\nactual_type, value, strict, _globals=_globals, _locals=_locals\n)\nif issubclass(actual_type, IList):\nreturn _i_list_from_json(\ntype_, value, strict, _globals=_globals, _locals=_locals\n)\nobj = json.loads(value)\nif strict:\nreturn _cast_to_annotation(\ntype_, value=obj, _globals=_globals, _locals=_locals\n)\nelse:\nreturn _try_cast_to_annotation(\ntype_, value=obj, _globals=_globals, _locals=_locals\n)\nfinally:\ndel frame\n</code></pre>"},{"location":"reference/#funml.if_err","title":"<code>if_err(do, strict=True)</code>","text":"<p>Does the given operation if value passed to resulting expression is Result.ERR.</p> <p>If the value is Result.OK, it just returns the Result.OK without doing anything about it.</p> <p>Parameters:</p> Name Type Description Default <code>do</code> <code>Union[Expression, Callable, Any]</code> <p>The expression, function, to run or value to return when Result.ERR</p> required <code>strict</code> <code>bool</code> <p>if only Results should be expected</p> <code>True</code> Example <pre><code>import funml as ml\nok_value = ml.Result.OK(90)\nerr_value = ml.Result.ERR(TypeError(\"some stuff\"))\nanother_value = None\n# in case the value may not be a Result, set strict to False\nprint(ml.if_err(str, strict=False)(another_value))\n# prints None\nerr_to_str = ml.if_err(str)\nprint(err_to_str(err_value))\n# prints 'some stuff'\nprint(err_to_str(ok_value))\n# prints &lt;Result.OK: ('90',)&gt;\n</code></pre> <p>Returns:</p> Type Description <code>Expression</code> <p>An expression to run the <code>do</code> operation when value passed to expression is Result.ERR</p> <code>Expression</code> <p>or to just return the Result.OK</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not a Result if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def if_err(do: Union[Expression, Callable, Any], strict: bool = True) -&gt; Expression:\n\"\"\"Does the given operation if value passed to resulting expression is Result.ERR.\n    If the value is Result.OK, it just returns the Result.OK without\n    doing anything about it.\n    Args:\n        do: The expression, function, to run or value to return when Result.ERR\n        strict: if only Results should be expected\n    Example:\n        ```python\n        import funml as ml\n        ok_value = ml.Result.OK(90)\n        err_value = ml.Result.ERR(TypeError(\"some stuff\"))\n        another_value = None\n        # in case the value may not be a Result, set strict to False\n        print(ml.if_err(str, strict=False)(another_value))\n        # prints None\n        err_to_str = ml.if_err(str)\n        print(err_to_str(err_value))\n        # prints 'some stuff'\n        print(err_to_str(ok_value))\n        # prints &lt;Result.OK: ('90',)&gt;\n        ```\n    Returns:\n        An expression to run the `do` operation when value passed to expression is Result.ERR\n        or to just return the Result.OK\n    Raises:\n        funml.errors.MatchError: value provided was not a Result if strict is True\n    \"\"\"\nroutine = (\nmatch()\n.case(Result.OK(Any), do=lambda v: Result.OK(v))\n.case(Result.ERR(Exception), do=to_expn(do))\n)\nif not strict:\nroutine = routine.case(Any, do=lambda v: v)\nreturn Expression(Operation(routine))\n</code></pre>"},{"location":"reference/#funml.if_none","title":"<code>if_none(do, strict=True)</code>","text":"<p>Does the given operation if value passed to resulting expression is Option.NONE.</p> <p>If the value is Option.SOME, it just returns the Option.SOME without doing anything about it.</p> <p>Parameters:</p> Name Type Description Default <code>do</code> <code>Union[Expression, Callable, Any]</code> <p>The expression, function, to run or value to return when Option.NONE</p> required <code>strict</code> <code>bool</code> <p>if only Options should be expected</p> <code>True</code> Example <pre><code>import funml as ml\nsome_value = ml.Option.SOME(90)\nnone_value = ml.Option.NONE\nanother_value = None\n# in case the value may not be an Option, set strict to False\nprint(ml.if_none(str, strict=False)(another_value))\n# prints None\nnone_to_str = ml.if_none(str)\nprint(none_to_str(some_value))\n# prints &lt;Option.SOME: (90,)&gt;\nprint(none_to_str(none_value))\n# prints ('NONE',)\n</code></pre> <p>Returns:</p> Type Description <code>Expression</code> <p>An expression to run the <code>do</code> operation when value passed to expression is Option.NONE</p> <code>Expression</code> <p>or to just return the Option.SOME</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not an Option if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def if_none(do: Union[Expression, Callable, Any], strict: bool = True) -&gt; Expression:\n\"\"\"Does the given operation if value passed to resulting expression is Option.NONE.\n    If the value is Option.SOME, it just returns the Option.SOME without\n    doing anything about it.\n    Args:\n        do: The expression, function, to run or value to return when Option.NONE\n        strict: if only Options should be expected\n    Example:\n        ```python\n        import funml as ml\n        some_value = ml.Option.SOME(90)\n        none_value = ml.Option.NONE\n        another_value = None\n        # in case the value may not be an Option, set strict to False\n        print(ml.if_none(str, strict=False)(another_value))\n        # prints None\n        none_to_str = ml.if_none(str)\n        print(none_to_str(some_value))\n        # prints &lt;Option.SOME: (90,)&gt;\n        print(none_to_str(none_value))\n        # prints ('NONE',)\n        ```\n    Returns:\n        An expression to run the `do` operation when value passed to expression is Option.NONE\n        or to just return the Option.SOME\n    Raises:\n        funml.errors.MatchError: value provided was not an Option if strict is True\n    \"\"\"\nroutine = (\nmatch()\n.case(Option.SOME(Any), do=lambda v: Option.SOME(v))\n.case(Option.NONE, do=to_expn(do))\n)\nif not strict:\nroutine = routine.case(Any, do=lambda v: v)\nreturn Expression(Operation(routine))\n</code></pre>"},{"location":"reference/#funml.if_ok","title":"<code>if_ok(do, strict=True)</code>","text":"<p>Does the given operation if value passed to resulting expression is Result.OK.</p> <p>If the value is Result.ERR, it just returns the Result.ERR without doing anything about it.</p> <p>Parameters:</p> Name Type Description Default <code>do</code> <code>Union[Expression, Callable, Any]</code> <p>The expression, function to run or value to return when Result.OK</p> required <code>strict</code> <code>bool</code> <p>if only Results should be expected</p> <code>True</code> Example <pre><code>import funml as ml\nok_value = ml.Result.OK(90)\nerr_value = ml.Result.ERR(TypeError(\"some stuff\"))\nanother_value = None\n# in case the value may not be a Result, set strict to False\nprint(ml.if_ok(str, strict=False)(another_value))\n# prints None\nok_to_str = ml.if_ok(str)\nprint(ok_to_str(err_value))\n# prints &lt;Result.ERR: (TypeError('some stuff'),)&gt;\nprint(ok_to_str(ok_value))\n# prints 90\n</code></pre> <p>Returns:</p> Type Description <code>Expression</code> <p>An expression to run the <code>do</code> operation when value passed to expression is Result.OK</p> <code>Expression</code> <p>or to just return the Result.ERR</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not a Result and <code>strict</code> is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def if_ok(do: Union[Expression, Callable, Any], strict: bool = True) -&gt; Expression:\n\"\"\"Does the given operation if value passed to resulting expression is Result.OK.\n    If the value is Result.ERR, it just returns the Result.ERR without\n    doing anything about it.\n    Args:\n        do: The expression, function to run or value to return when Result.OK\n        strict: if only Results should be expected\n    Example:\n        ```python\n        import funml as ml\n        ok_value = ml.Result.OK(90)\n        err_value = ml.Result.ERR(TypeError(\"some stuff\"))\n        another_value = None\n        # in case the value may not be a Result, set strict to False\n        print(ml.if_ok(str, strict=False)(another_value))\n        # prints None\n        ok_to_str = ml.if_ok(str)\n        print(ok_to_str(err_value))\n        # prints &lt;Result.ERR: (TypeError('some stuff'),)&gt;\n        print(ok_to_str(ok_value))\n        # prints 90\n        ```\n    Returns:\n        An expression to run the `do` operation when value passed to expression is Result.OK\n        or to just return the Result.ERR\n    Raises:\n        funml.errors.MatchError: value provided was not a Result and `strict` is True\n    \"\"\"\nroutine = (\nmatch()\n.case(Result.OK(Any), do=to_expn(do))\n.case(Result.ERR(Exception), do=lambda v: Result.ERR(v))\n)\nif not strict:\nroutine = routine.case(Any, do=lambda v: v)\nreturn Expression(Operation(routine))\n</code></pre>"},{"location":"reference/#funml.if_some","title":"<code>if_some(do, strict=True)</code>","text":"<p>Does the given operation if value passed to resulting expression is Option.SOME.</p> <p>If the value is Result.NONE, it just returns the Result.NONE without doing anything about it.</p> <p>Parameters:</p> Name Type Description Default <code>do</code> <code>Union[Expression, Callable, Any]</code> <p>The expression, function, to run or value to return when Option.SOME</p> required <code>strict</code> <code>bool</code> <p>if only Options should be expected</p> <code>True</code> Example <pre><code>import funml as ml\nsome_value = ml.Option.SOME(90)\nnone_value = ml.Option.NONE\nanother_value = None\n# in case the value may not be an Option, set strict to False\nprint(ml.if_some(str, strict=False)(another_value))\n# prints None\nsome_to_str = ml.if_some(str)\nprint(some_to_str(some_value))\n# prints 90\nprint(some_to_str(none_value))\n# prints &lt;Option.NONE: ('NONE',)&gt;\n</code></pre> <p>Returns:</p> Type Description <code>Expression</code> <p>An expression to run the <code>do</code> operation when value passed to expression is Option.SOME</p> <code>Expression</code> <p>or to just return the Option.NONE</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not an Option if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def if_some(do: Union[Expression, Callable, Any], strict: bool = True) -&gt; Expression:\n\"\"\"Does the given operation if value passed to resulting expression is Option.SOME.\n    If the value is Result.NONE, it just returns the Result.NONE without\n    doing anything about it.\n    Args:\n        do: The expression, function, to run or value to return when Option.SOME\n        strict: if only Options should be expected\n    Example:\n        ```python\n        import funml as ml\n        some_value = ml.Option.SOME(90)\n        none_value = ml.Option.NONE\n        another_value = None\n        # in case the value may not be an Option, set strict to False\n        print(ml.if_some(str, strict=False)(another_value))\n        # prints None\n        some_to_str = ml.if_some(str)\n        print(some_to_str(some_value))\n        # prints 90\n        print(some_to_str(none_value))\n        # prints &lt;Option.NONE: ('NONE',)&gt;\n        ```\n    Returns:\n        An expression to run the `do` operation when value passed to expression is Option.SOME\n        or to just return the Option.NONE\n    Raises:\n        funml.errors.MatchError: value provided was not an Option if strict is True\n    \"\"\"\nroutine = (\nmatch()\n.case(Option.SOME(Any), do=to_expn(do))\n.case(Option.NONE, do=lambda: Option.NONE)\n)\nif not strict:\nroutine = routine.case(Any, do=lambda v: v)\nreturn Expression(Operation(routine))\n</code></pre>"},{"location":"reference/#funml.ifilter","title":"<code>ifilter(func)</code>","text":"<p>Creates an expression to transform each item by the given function.</p> <p>Expressions can be computed lazily at any time.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Any], Any]</code> <p>the function to use to check if item should remain or be ignored.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new iList with only the items of data that returned true when <code>func</code> was called on them.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def ifilter(func: Callable[[Any], Any]) -&gt; Expression:\n\"\"\"Creates an expression to transform each item by the given function.\n    Expressions can be computed lazily at any time.\n    Args:\n        func: the function to use to check if item should remain or be ignored.\n    Returns:\n        A new iList with only the items of data that returned true when `func` was called on them.\n    \"\"\"\nop = Operation(lambda data: IList(*filter(func, data)))\nreturn Expression(op)\n</code></pre>"},{"location":"reference/#funml.imap","title":"<code>imap(func)</code>","text":"<p>Creates an expression to transform each item by the given function.</p> <p>Expressions can be computed lazily at any time.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Any], Any]</code> <p>the function to use to transform each item</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new IList with each item in data transformed according to the <code>func</code> function.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def imap(func: Callable[[Any], Any]) -&gt; Expression:\n\"\"\"Creates an expression to transform each item by the given function.\n    Expressions can be computed lazily at any time.\n    Args:\n        func: the function to use to transform each item\n    Returns:\n            A new IList with each item in data transformed according to the `func` function.\n    \"\"\"\nop = Operation(lambda data: IList(*[func(v) for v in data]))\nreturn Expression(op)\n</code></pre>"},{"location":"reference/#funml.ireduce","title":"<code>ireduce(func, initial=None)</code>","text":"<p>Creates an expression to reduce a sequence into one value using the given <code>func</code>.</p> <p>Expressions can be computed lazily at any time.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Any, Any], Any]</code> <p>the function to reduce the sequence into a single value.</p> required <code>initial</code> <code>Optional[Any]</code> <p>the initial value that acts like a default when sequence is empty,     and is added onto by <code>func</code> when sequence has some items.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A single item got from calling <code>func</code> repeatedly across the sequence for every</p> <code>Expression</code> <p>two adjacent items.</p> Source code in <code>funml/data/lists.py</code> <pre><code>def ireduce(\nfunc: Callable[[Any, Any], Any], initial: Optional[Any] = None\n) -&gt; Expression:\n\"\"\"Creates an expression to reduce a sequence into one value using the given `func`.\n    Expressions can be computed lazily at any time.\n    Args:\n        func: the function to reduce the sequence into a single value.\n        initial: the initial value that acts like a default when sequence is empty,\n                and is added onto by `func` when sequence has some items.\n    Returns:\n        A single item got from calling `func` repeatedly across the sequence for every\n        two adjacent items.\n    \"\"\"\nif initial is None:\nop = Operation(lambda data: reduce(func, data))\nelse:\nop = Operation(lambda data: reduce(func, data, initial))\nreturn Expression(op)\n</code></pre>"},{"location":"reference/#funml.is_err","title":"<code>is_err(v, strict=True)</code>","text":"<p>Checks if <code>v</code> is Result.ERR.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Result</code> <p>The value to check</p> required <code>strict</code> <code>bool</code> <p>if value should be a Result</p> <code>True</code> Example <pre><code>import funml as ml\nok_value = ml.Result.OK(90)\nerr_value = ml.Result.ERR(TypeError())\nprint(ml.is_err(ok_value))\n# prints False\nprint(ml.is_err(err_value))\n# prints True\nanother_value = None\n# in case the value is not always a Result, set `strict` to False\n# to avoid a MatchError\nprint(ml.is_err(another_value, strict=False))\n# prints False\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>v</code> is a Result.ERR else False</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not a Result if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def is_err(v: \"Result\", strict: bool = True) -&gt; bool:\n\"\"\"Checks if `v` is Result.ERR.\n    Args:\n        v: The value to check\n        strict: if value should be a Result\n    Example:\n        ```python\n        import funml as ml\n        ok_value = ml.Result.OK(90)\n        err_value = ml.Result.ERR(TypeError())\n        print(ml.is_err(ok_value))\n        # prints False\n        print(ml.is_err(err_value))\n        # prints True\n        another_value = None\n        # in case the value is not always a Result, set `strict` to False\n        # to avoid a MatchError\n        print(ml.is_err(another_value, strict=False))\n        # prints False\n        ```\n    Returns:\n        True if `v` is a Result.ERR else False\n    Raises:\n        funml.errors.MatchError: value provided was not a Result if strict is True\n    \"\"\"\nnegative_pattern = Result.OK(Any) if strict else Any\nreturn (\nmatch()\n.case(Result.ERR(Exception), do=lambda: True)\n.case(negative_pattern, do=lambda: False)\n)(v)\n</code></pre>"},{"location":"reference/#funml.is_none","title":"<code>is_none(v, strict=True)</code>","text":"<p>Checks if <code>v</code> is Option.NONE.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Option</code> <p>The value to check</p> required <code>strict</code> <code>bool</code> <p>if value should be a Option</p> <code>True</code> Example <pre><code>import funml as ml\nsome_value = ml.Option.SOME(90)\nnone_value = ml.Option.NONE\nprint(ml.is_none(some_value))\n# prints False\nprint(ml.is_none(none_value))\n# prints True\nanother_value = None\n# in case the value is not always an Option, set `strict` to False\n# to avoid a MatchError\nprint(ml.is_none(another_value, strict=False))\n# prints False\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>v</code> is a Option.NONE else False</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not an Option if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def is_none(v: \"Option\", strict: bool = True) -&gt; bool:\n\"\"\"Checks if `v` is Option.NONE.\n    Args:\n        v: The value to check\n        strict: if value should be a Option\n    Example:\n        ```python\n        import funml as ml\n        some_value = ml.Option.SOME(90)\n        none_value = ml.Option.NONE\n        print(ml.is_none(some_value))\n        # prints False\n        print(ml.is_none(none_value))\n        # prints True\n        another_value = None\n        # in case the value is not always an Option, set `strict` to False\n        # to avoid a MatchError\n        print(ml.is_none(another_value, strict=False))\n        # prints False\n        ```\n    Returns:\n        True if `v` is a Option.NONE else False\n    Raises:\n        funml.errors.MatchError: value provided was not an Option if strict is True\n    \"\"\"\nnegative_pattern = Option.SOME(Any) if strict else Any\nreturn (\nmatch()\n.case(Option.NONE, do=lambda: True)\n.case(negative_pattern, do=lambda: False)\n)(v)\n</code></pre>"},{"location":"reference/#funml.is_ok","title":"<code>is_ok(v, strict=True)</code>","text":"<p>Checks if <code>v</code> is Result.OK.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Result</code> <p>The value to check</p> required <code>strict</code> <code>bool</code> <p>if value should be a Result</p> <code>True</code> Example <pre><code>import funml as ml\nok_value = ml.Result.OK(90)\nerr_value = ml.Result.ERR(TypeError())\nprint(ml.is_ok(ok_value))\n# prints True\nprint(ml.is_ok(err_value))\n# prints False\nanother_value = None\n# in case the value is not always a Result, set `strict` to False\n# to avoid a MatchError\nprint(ml.is_ok(another_value, strict=False))\n# prints False\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>v</code> is a Result.OK else False</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not a Result if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def is_ok(v: \"Result\", strict: bool = True) -&gt; bool:\n\"\"\"Checks if `v` is Result.OK.\n    Args:\n        v: The value to check\n        strict: if value should be a Result\n    Example:\n        ```python\n        import funml as ml\n        ok_value = ml.Result.OK(90)\n        err_value = ml.Result.ERR(TypeError())\n        print(ml.is_ok(ok_value))\n        # prints True\n        print(ml.is_ok(err_value))\n        # prints False\n        another_value = None\n        # in case the value is not always a Result, set `strict` to False\n        # to avoid a MatchError\n        print(ml.is_ok(another_value, strict=False))\n        # prints False\n        ```\n    Returns:\n        True if `v` is a Result.OK else False\n    Raises:\n        funml.errors.MatchError: value provided was not a Result if strict is True\n    \"\"\"\nnegative_pattern = Result.ERR(Exception) if strict else Any\nreturn (\nmatch()\n.case(Result.OK(Any), do=lambda: True)\n.case(negative_pattern, do=lambda: False)\n)(v)\n</code></pre>"},{"location":"reference/#funml.is_some","title":"<code>is_some(v, strict=True)</code>","text":"<p>Checks if <code>v</code> is Option.SOME.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Option</code> <p>The value to check</p> required <code>strict</code> <code>bool</code> <p>if value should be a Option</p> <code>True</code> Example <pre><code>import funml as ml\nsome_value = ml.Option.SOME(90)\nnone_value = ml.Option.NONE\nprint(ml.is_some(some_value))\n# prints True\nprint(ml.is_some(none_value))\n# prints False\nanother_value = None\n# in case the value is not always an Option, set `strict` to False\n# to avoid a MatchError\nprint(ml.is_some(another_value, strict=False))\n# prints False\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>v</code> is a Option.SOME else False</p> <p>Raises:</p> Type Description <code>funml.errors.MatchError</code> <p>value provided was not an Option if strict is True</p> Source code in <code>funml/data/monads.py</code> <pre><code>def is_some(v: \"Option\", strict: bool = True) -&gt; bool:\n\"\"\"Checks if `v` is Option.SOME.\n    Args:\n        v: The value to check\n        strict: if value should be a Option\n    Example:\n        ```python\n        import funml as ml\n        some_value = ml.Option.SOME(90)\n        none_value = ml.Option.NONE\n        print(ml.is_some(some_value))\n        # prints True\n        print(ml.is_some(none_value))\n        # prints False\n        another_value = None\n        # in case the value is not always an Option, set `strict` to False\n        # to avoid a MatchError\n        print(ml.is_some(another_value, strict=False))\n        # prints False\n        ```\n    Returns:\n        True if `v` is a Option.SOME else False\n    Raises:\n        funml.errors.MatchError: value provided was not an Option if strict is True\n    \"\"\"\nnegative_pattern = Option.NONE if strict else Any\nreturn (\nmatch()\n.case(Option.SOME(Any), do=lambda: True)\n.case(negative_pattern, do=lambda: False)\n)(v)\n</code></pre>"},{"location":"reference/#funml.l","title":"<code>l(*args)</code>","text":"<p>Creates an immutable list of any type of items.</p> <p>Creates a list of items of any type, that cannot be changed once created. It can only be used to create other lists, using methods on it like</p> <ul> <li><code>+</code> - to combine two separate lists into a new one containing elements of both</li> <li><code>imap(fn)</code> - to create a new list with each element transformed according to the given function <code>fn</code></li> <li><code>filter(fn)</code> - to return a new list containing only elements that conform to the given function <code>fn</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>the items that make up the list</p> <code>()</code> <p>Returns:</p> Type Description <code>IList</code> <p>An immutable list, `IList, containing the items passed to it.</p> Example <pre><code>import funml as ml\nitems = ml.l(120, 13, 40, 60, \"hey\", \"men\")\n# or items = ml.l(item for item in values) where values is an iterable\nnum_filter = ml.ifilter(lambda x: isinstance(x, (int, float)))\nstr_filter = ml.ifilter(lambda x: isinstance(x, str))\nnums = num_filter(items)\nstrings = str_filter(items)\ndouble_transform = ml.imap(lambda x: x*2)\ndoubled_nums = double_transform(nums)\naggregator = ml.ireduce(lambda x, y: f\"{x}, {y}\")\nlist_as_str = aggregator(items)\nprint(nums)\n# prints [120, 13, 40, 60]\nprint(strings)\n# prints [\"hey\", \"men\"]\nprint(doubled_nums)\n# prints [240, 26, 80, 120]\nprint(list_as_str)\n# prints '120, 13, 40, 60, hey, men'\n</code></pre> Source code in <code>funml/data/lists.py</code> <pre><code>def l(*args: Any) -&gt; \"IList\":\n\"\"\"Creates an immutable list of any type of items.\n    Creates a list of items of any type, that cannot be changed\n    once created. It can only be used to create other lists, using methods on it like\n    - [`+`][funml.IList.__add__] - to combine two separate lists into a new one containing elements of both\n    - [`imap(fn)`][funml.imap] - to create a new list with each element transformed according to the given function `fn`\n    - [`filter(fn)`][funml.ifilter] - to return a new list containing only elements that conform to the given function `fn`\n    Args:\n        args: the items that make up the list\n    Returns:\n        An immutable list, [`IList][funml.IList], containing the items passed to it.\n    Example:\n        ```python\n        import funml as ml\n        items = ml.l(120, 13, 40, 60, \"hey\", \"men\")\n        # or items = ml.l(item for item in values) where values is an iterable\n        num_filter = ml.ifilter(lambda x: isinstance(x, (int, float)))\n        str_filter = ml.ifilter(lambda x: isinstance(x, str))\n        nums = num_filter(items)\n        strings = str_filter(items)\n        double_transform = ml.imap(lambda x: x*2)\n        doubled_nums = double_transform(nums)\n        aggregator = ml.ireduce(lambda x, y: f\"{x}, {y}\")\n        list_as_str = aggregator(items)\n        print(nums)\n        # prints [120, 13, 40, 60]\n        print(strings)\n        # prints [\"hey\", \"men\"]\n        print(doubled_nums)\n        # prints [240, 26, 80, 120]\n        print(list_as_str)\n        # prints '120, 13, 40, 60, hey, men'\n        ```\n    \"\"\"\nreturn IList(*args)\n</code></pre>"},{"location":"reference/#funml.match","title":"<code>match(arg=None)</code>","text":"<p>Matches the argument with a corresponding case, and calls it <code>do</code> operation.</p> <p>It runs through a range of cases, looking for any that match the current arg. If it finds it, it calls the <code>do</code> operation attached to that case.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>Optional[Any]</code> <p>the argument which is to be checked against the list of patterns.</p> <code>None</code> <p>Returns:</p> Type Description <code>MatchExpression</code> <p>A <code>MatchExpression</code> containing the matched operation.</p> <p>Raises:</p> Type Description <code>MatchError</code> <p>failed to find a match for the argument.</p> Example <pre><code>import funml as ml\n@ml.record\nclass Color:\nr: int\ng: int\nb: int\nraw_value = ml.Option.SOME(90)\nvalue = (\nml.match(raw_value)\n.case(ml.Option.SOME(int), do=lambda v: v + 6)\n.case(ml.Option.NONE, do=lambda: \"nothing to show\")\n.case(Color(red=255), do=lambda v: v.red + v.green)\n.case(ml.l(..., 5), do=lambda v: v)\n.case(ml.l(8, 5, ...), do=lambda v: str(v))\n)()\nprint(value)\n# prints 96\n</code></pre> Source code in <code>funml/pattern_match.py</code> <pre><code>def match(arg: Optional[Any] = None) -&gt; \"MatchExpression\":\n\"\"\"Matches the argument with a corresponding case, and calls it `do` operation.\n    It runs through a range of cases, looking for any that match\n    the current arg. If it finds it, it calls the `do` operation attached\n    to that case.\n    Args:\n        arg: the argument which is to be checked against the list of patterns.\n    Returns:\n        A [`MatchExpression`][funml.types.MatchExpression] containing the matched operation.\n    Raises:\n        MatchError: failed to find a match for the argument.\n    Example:\n        ```python\n        import funml as ml\n        @ml.record\n        class Color:\n            r: int\n            g: int\n            b: int\n        raw_value = ml.Option.SOME(90)\n        value = (\n            ml.match(raw_value)\n                .case(ml.Option.SOME(int), do=lambda v: v + 6)\n                .case(ml.Option.NONE, do=lambda: \"nothing to show\")\n                .case(Color(red=255), do=lambda v: v.red + v.green)\n                .case(ml.l(..., 5), do=lambda v: v)\n                .case(ml.l(8, 5, ...), do=lambda v: str(v))\n        )()\n        print(value)\n        # prints 96\n        ```\n    \"\"\"\nreturn MatchExpression(arg=arg)\n</code></pre>"},{"location":"reference/#funml.record","title":"<code>record(cls)</code>","text":"<p>Creates a Schema type to create similar records.</p> <p>Used usually as a decorator inplace of @dataclass on dataclass-like classes to make them ml-functional.</p> <p>It creates a Schema for similar objects that contain a given set of attributes. For example, it can create a <code>Book</code> schema whose attributes include <code>author</code>, <code>title</code>, <code>isbn</code> etc.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[R]</code> <p>the class to transform into a record</p> required <p>Returns:</p> Type Description <code>Type[R]</code> <p>A class which can act as a record of the particular schema         set by the attributes.</p> Example <pre><code>import funml as ml\n@ml.record\nclass Color:\nred: int\ngreen: int\nblue: int\nalpha: int = 1\nindigo = Color(red=75, green=0, blue=130)\nprint(indigo)\n# prints {'red': 75, 'green': 0, 'blue': 130, 'alpha': 1}\n</code></pre> Source code in <code>funml/data/records.py</code> <pre><code>@dataclass_transform(\nfield_specifiers=(dataclasses.Field, dataclasses.field),\n)\ndef record(cls: Type[R]) -&gt; Type[R]:\n\"\"\"Creates a Schema type to create similar records.\n    Used usually as a decorator inplace of @dataclass\n    on dataclass-like classes to make them ml-functional.\n    It creates a Schema for similar objects that contain a given\n    set of attributes. For example, it can create a `Book` schema\n    whose attributes include `author`, `title`, `isbn` etc.\n    Args:\n        cls: the class to transform into a record\n    Returns:\n        A class which can act as a record of the particular schema \\\n        set by the attributes.\n    Example:\n        ```python\n        import funml as ml\n        @ml.record\n        class Color:\n            red: int\n            green: int\n            blue: int\n            alpha: int = 1\n        indigo = Color(red=75, green=0, blue=130)\n        print(indigo)\n        # prints {'red': 75, 'green': 0, 'blue': 130, 'alpha': 1}\n        ```\n    \"\"\"\n_annotations = cls.__annotations__\nreturn dataclasses.dataclass(\ntype(\ncls.__name__,\n(\nRecord,\ncls,\n),\n{\n\"__annotations__\": _annotations,\n\"__slots__\": tuple(_annotations.keys()),\n\"__defaults__\": _get_cls_defaults(cls, _annotations=_annotations),\n\"__is_normalized__\": False,\n\"__module_path__\": cls.__module__,\n},\n),\ninit=False,\nrepr=False,\n)\n</code></pre>"},{"location":"reference/#funml.to_dict","title":"<code>to_dict(v)</code>","text":"<p>Converts a record into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Record</code> <p>the <code>Record</code> to convert to dict</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>the dictionary representation of the record</p> Example <pre><code>import funml as ml\n@ml.record\nclass Department:\nseniors: list[str]\njuniors: List[str]\nlocations: tuple[str, ...]\nmisc: dict[str, Any]\nhead: str\nsc_dept = Department(\nseniors=[\"Joe\", \"Jane\"],\njuniors=[\"Herbert\", \"Leo\"],\nlocations=(\"Kasasa\", \"Bujumbura\", \"Bugahya\"),\nmisc={\"short_name\": \"ScDept\"},\nhead=\"John\",\n)\ndata = ml.to_dict(sc_dept)\nprint(data)\n</code></pre> Source code in <code>funml/data/records.py</code> <pre><code>def to_dict(v: \"Record\") -&gt; Dict[str, Any]:\n\"\"\"Converts a record into a dictionary.\n    Args:\n        v: the `Record` to convert to dict\n    Returns:\n        the dictionary representation of the record\n    Example:\n        ```python\n        import funml as ml\n        @ml.record\n        class Department:\n            seniors: list[str]\n            juniors: List[str]\n            locations: tuple[str, ...]\n            misc: dict[str, Any]\n            head: str\n        sc_dept = Department(\n            seniors=[\"Joe\", \"Jane\"],\n            juniors=[\"Herbert\", \"Leo\"],\n            locations=(\"Kasasa\", \"Bujumbura\", \"Bugahya\"),\n            misc={\"short_name\": \"ScDept\"},\n            head=\"John\",\n        )\n        data = ml.to_dict(sc_dept)\n        print(data)\n        ```\n    \"\"\"\nreturn dict(v)\n</code></pre>"},{"location":"reference/#funml.to_json","title":"<code>to_json(value)</code>","text":"<p>Converts the type into a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>the value to convert to a JSON string</p> required <p>Returns:</p> Type Description <code>str</code> <p>the JSON string representation of this instance</p> Example <pre><code>import funml as ml\n@ml.record\nclass Student:\nname: str\nfavorite_color: \"Color\"\n@ml.record\nclass Color:\nr: int\ng: int\nb: int\na: \"Alpha\"\nclass Alpha(ml.Enum):\nOPAQUE = None\nTRANSLUCENT = float\nitems = [\nml.l(\nTrue,\nColor(r=8, g=4, b=78, a=Alpha.OPAQUE),\nColor(r=55, g=40, b=9, a=Alpha.TRANSLUCENT(0.4)),\n),\nColor(r=8, g=4, b=78, a=Alpha.OPAQUE),\nAlpha.TRANSLUCENT(0.4),\n]\nfor item in items:\nitem_json = ml.to_json(item)\nprint(item_json)\n</code></pre> Source code in <code>funml/json.py</code> <pre><code>def to_json(value: Any) -&gt; str:\n\"\"\"Converts the type into a JSON string.\n    Args:\n        value: the value to convert to a JSON string\n    Returns:\n        the JSON string representation of this instance\n    Example:\n        ```python\n        import funml as ml\n        @ml.record\n        class Student:\n            name: str\n            favorite_color: \"Color\"\n        @ml.record\n        class Color:\n            r: int\n            g: int\n            b: int\n            a: \"Alpha\"\n        class Alpha(ml.Enum):\n            OPAQUE = None\n            TRANSLUCENT = float\n        items = [\n            ml.l(\n                True,\n                Color(r=8, g=4, b=78, a=Alpha.OPAQUE),\n                Color(r=55, g=40, b=9, a=Alpha.TRANSLUCENT(0.4)),\n            ),\n            Color(r=8, g=4, b=78, a=Alpha.OPAQUE),\n            Alpha.TRANSLUCENT(0.4),\n        ]\n        for item in items:\n            item_json = ml.to_json(item)\n            print(item_json)\n        ```\n    \"\"\"\nif isinstance(value, Enum):\nreturn _enum_to_json(value)\nif isinstance(value, Record):\nreturn _record_to_json(value)\nif isinstance(value, IList):\nreturn _i_list_to_json(value)\nif isinstance(value, (tuple, list, set)):\nreturn f\"[{', '.join([to_json(v) for v in value])}]\"\nif isinstance(value, dict):\nitems = [f'\"{k}\": {to_json(v)}' for k, v in value.items()]\nreturn f\"{{{', '.join(items)}}}\"\nreturn json.dumps(value)\n</code></pre>"},{"location":"reference/#funml.val","title":"<code>val(v)</code>","text":"<p>Converts a generic value or lambda expression into a functional expression.</p> <p>This is useful when one needs to use piping on a non-ml function or value. It is like the connection that give non-ml values and functions capabilities to be used in the ml world.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Union[Expression, Callable, Any]</code> <p>the value e.g. 90 or function e.g. <code>min</code></p> required <p>Returns:</p> Type Description <code>Expression</code> <p>an ml <code>Expression</code> that can be piped to other ml-expressions or invoked to return its        output.</p> Example <pre><code>import funml as ml\nml_min = ml.val(min)\nml_min_str = ml_min &gt;&gt; str\nexpn = ml.val([6, 7, 12]) &gt;&gt; ml_min_str\nexpn()\n# returns '6'\n</code></pre> Source code in <code>funml/expressions.py</code> <pre><code>def val(v: Union[Expression, Callable, Any]) -&gt; Expression:\n\"\"\"Converts a generic value or lambda expression into a functional expression.\n    This is useful when one needs to use piping on a non-ml function or\n    value. It is like the connection that give non-ml values and functions\n    capabilities to be used in the ml world.\n    Args:\n        v: the value e.g. 90 or function e.g. `min`\n    Returns:\n        an ml [`Expression`][funml.types.Expression] that can be piped to other ml-expressions or invoked to return its\\\n        output.\n    Example:\n        ```python\n        import funml as ml\n        ml_min = ml.val(min)\n        ml_min_str = ml_min &gt;&gt; str\n        expn = ml.val([6, 7, 12]) &gt;&gt; ml_min_str\n        expn()\n        # returns '6'\n        ```\n    \"\"\"\nreturn to_expn(v)\n</code></pre>"},{"location":"reference/#types","title":"Types","text":"<p>All types used by funml</p>"},{"location":"reference/#funml.types.Pipeline","title":"<code>Pipeline</code>","text":"<p>A series of logic blocks that operate on the same data in sequence.</p> <p>This has internal state so it is not be used in such stuff as recursion. However when compile is run on it, a reusable (pure) expression is created.</p> Source code in <code>funml/types.py</code> <pre><code>class Pipeline:\n\"\"\"A series of logic blocks that operate on the same data in sequence.\n    This has internal state so it is not be used in such stuff as recursion.\n    However when compile is run on it, a reusable (pure) expression is created.\n    \"\"\"\ndef __init__(self):\nself._queue: List[Expression] = []\nself._is_terminated = False\ndef __rshift__(\nself,\nnxt: Union[\n\"Expression\",\nCallable,\n\"Pipeline\",\n],\n) -&gt; Union[\"Pipeline\", Any]:\n\"\"\"Uses `&gt;&gt;` to append the nxt expression, callable, pipeline to this pipeline.\n        Args:\n            nxt: the next expression, pipeline, or callable to apply after the current one.\n        Returns:\n            the updated pipeline or the value when the pipeline is executed in case `nxt` is of \\\n            type `ExecutionExpression`\n        Raises:\n            ValueError: when the pipeline is already terminated with ml.execute() in its queue.\n        \"\"\"\nself.__update_queue(nxt)\nif self._is_terminated:\nreturn self()\nreturn self\ndef __call__(\nself, *args: Any, **kwargs: Any\n) -&gt; Union[\"Expression\", Awaitable[\"Expression\"], Awaitable[Any], Any,]:\n\"\"\"Computes the logic within the pipeline and returns the value.\n        This method runs all those expressions in the queue sequentially,\n        with the output of an expression being used as\n        input for the next expression.\n        Args:\n            args: any arguments passed.\n            kwargs: any key-word arguments passed\n        Returns:\n            the computed output of this pipeline or a partial expression if the args and kwargs provided are less than those expected.\n        \"\"\"\noutput = None\nqueue = self._queue[:-1] if self._is_terminated else self._queue\nis_async = False\nfor expn in queue:\nif output is None:\noutput = expn(*args, **kwargs)\nelif isinstance(output, Awaitable):\nis_async = True\nbreak\nelse:\n# make sure piped expressions only consume previous outputs args, and kwargs\noutput = expn(output, **kwargs)\nif is_async:\nreturn self.__as_async()(*args, **kwargs)\nreturn output\ndef __copy__(self):\n\"\"\"Helps call copy on a pipeline\"\"\"\nnew_pipeline = Pipeline()\nnew_pipeline._queue += self._queue\nnew_pipeline._is_terminated = self._is_terminated\nreturn new_pipeline\ndef __as_async(self) -&gt; \"AsyncPipeline\":\n\"\"\"Creates an async pipeline from this pipeline\"\"\"\npipe = AsyncPipeline()\npipe._queue = [*self._queue]\npipe._is_terminated = self._is_terminated\nreturn pipe\ndef __update_queue(\nself,\nnxt: Union[\n\"Expression\",\nCallable,\n\"Pipeline\",\n],\n):\n\"\"\"Appends a pipeline or an expression to the queue.\"\"\"\nif self._is_terminated:\nraise ValueError(\"a terminated pipeline cannot be extended.\")\nif isinstance(nxt, Pipeline):\nself._queue += nxt._queue\nself._is_terminated = nxt._is_terminated\nelse:\nnxt_expn = to_expn(nxt)\nself._queue.append(nxt_expn)\nself._is_terminated = isinstance(nxt, ExecutionExpression)\n</code></pre>"},{"location":"reference/#funml.types.Pipeline.__as_async","title":"<code>__as_async()</code>","text":"<p>Creates an async pipeline from this pipeline</p> Source code in <code>funml/types.py</code> <pre><code>def __as_async(self) -&gt; \"AsyncPipeline\":\n\"\"\"Creates an async pipeline from this pipeline\"\"\"\npipe = AsyncPipeline()\npipe._queue = [*self._queue]\npipe._is_terminated = self._is_terminated\nreturn pipe\n</code></pre>"},{"location":"reference/#funml.types.Pipeline.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Computes the logic within the pipeline and returns the value.</p> <p>This method runs all those expressions in the queue sequentially, with the output of an expression being used as input for the next expression.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>any arguments passed.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>any key-word arguments passed</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Expression, Awaitable[Expression], Awaitable[Any], Any]</code> <p>the computed output of this pipeline or a partial expression if the args and kwargs provided are less than those expected.</p> Source code in <code>funml/types.py</code> <pre><code>def __call__(\nself, *args: Any, **kwargs: Any\n) -&gt; Union[\"Expression\", Awaitable[\"Expression\"], Awaitable[Any], Any,]:\n\"\"\"Computes the logic within the pipeline and returns the value.\n    This method runs all those expressions in the queue sequentially,\n    with the output of an expression being used as\n    input for the next expression.\n    Args:\n        args: any arguments passed.\n        kwargs: any key-word arguments passed\n    Returns:\n        the computed output of this pipeline or a partial expression if the args and kwargs provided are less than those expected.\n    \"\"\"\noutput = None\nqueue = self._queue[:-1] if self._is_terminated else self._queue\nis_async = False\nfor expn in queue:\nif output is None:\noutput = expn(*args, **kwargs)\nelif isinstance(output, Awaitable):\nis_async = True\nbreak\nelse:\n# make sure piped expressions only consume previous outputs args, and kwargs\noutput = expn(output, **kwargs)\nif is_async:\nreturn self.__as_async()(*args, **kwargs)\nreturn output\n</code></pre>"},{"location":"reference/#funml.types.Pipeline.__copy__","title":"<code>__copy__()</code>","text":"<p>Helps call copy on a pipeline</p> Source code in <code>funml/types.py</code> <pre><code>def __copy__(self):\n\"\"\"Helps call copy on a pipeline\"\"\"\nnew_pipeline = Pipeline()\nnew_pipeline._queue += self._queue\nnew_pipeline._is_terminated = self._is_terminated\nreturn new_pipeline\n</code></pre>"},{"location":"reference/#funml.types.Pipeline.__rshift__","title":"<code>__rshift__(nxt)</code>","text":"<p>Uses <code>&gt;&gt;</code> to append the nxt expression, callable, pipeline to this pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>nxt</code> <code>Union[Expression, Callable, Pipeline]</code> <p>the next expression, pipeline, or callable to apply after the current one.</p> required <p>Returns:</p> Type Description <code>Union[Pipeline, Any]</code> <p>the updated pipeline or the value when the pipeline is executed in case <code>nxt</code> is of             type <code>ExecutionExpression</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the pipeline is already terminated with ml.execute() in its queue.</p> Source code in <code>funml/types.py</code> <pre><code>def __rshift__(\nself,\nnxt: Union[\n\"Expression\",\nCallable,\n\"Pipeline\",\n],\n) -&gt; Union[\"Pipeline\", Any]:\n\"\"\"Uses `&gt;&gt;` to append the nxt expression, callable, pipeline to this pipeline.\n    Args:\n        nxt: the next expression, pipeline, or callable to apply after the current one.\n    Returns:\n        the updated pipeline or the value when the pipeline is executed in case `nxt` is of \\\n        type `ExecutionExpression`\n    Raises:\n        ValueError: when the pipeline is already terminated with ml.execute() in its queue.\n    \"\"\"\nself.__update_queue(nxt)\nif self._is_terminated:\nreturn self()\nreturn self\n</code></pre>"},{"location":"reference/#funml.types.Pipeline.__update_queue","title":"<code>__update_queue(nxt)</code>","text":"<p>Appends a pipeline or an expression to the queue.</p> Source code in <code>funml/types.py</code> <pre><code>def __update_queue(\nself,\nnxt: Union[\n\"Expression\",\nCallable,\n\"Pipeline\",\n],\n):\n\"\"\"Appends a pipeline or an expression to the queue.\"\"\"\nif self._is_terminated:\nraise ValueError(\"a terminated pipeline cannot be extended.\")\nif isinstance(nxt, Pipeline):\nself._queue += nxt._queue\nself._is_terminated = nxt._is_terminated\nelse:\nnxt_expn = to_expn(nxt)\nself._queue.append(nxt_expn)\nself._is_terminated = isinstance(nxt, ExecutionExpression)\n</code></pre>"},{"location":"reference/#funml.types.AsyncPipeline","title":"<code>AsyncPipeline</code>","text":"<p>         Bases: <code>Pipeline</code></p> <p>A pipeline for handling async code.</p> <p>See more details in the base class</p> Source code in <code>funml/types.py</code> <pre><code>class AsyncPipeline(Pipeline):\n\"\"\"A pipeline for handling async code.\n    See more details in the [base class](funml.types.Pipeline)\n    \"\"\"\nasync def __call__(self, *args: Any, **kwargs: Any) -&gt; Union[\"Expression\", Any]:\n\"\"\"Computes the logic within the pipeline and returns the value.\n        This method runs all those expressions in the queue sequentially,\n        with the output of an expression being used as\n        input for the next expression.\n        Args:\n            args: any arguments passed.\n            kwargs: any key-word arguments passed\n        Returns:\n            the computed output of this pipeline or a partial expression if the args and kwargs provided \\\n            are less than expected.\n        \"\"\"\noutput = None\nqueue = self._queue[:-1] if self._is_terminated else self._queue\nfor expn in queue:\nif output is None:\noutput = expn(*args, **kwargs)\nelif isinstance(output, Awaitable):\noutput = expn((await output), **kwargs)\nelse:\noutput = expn(output, **kwargs)\nreturn output\n</code></pre>"},{"location":"reference/#funml.types.AsyncPipeline.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Computes the logic within the pipeline and returns the value.</p> <p>This method runs all those expressions in the queue sequentially, with the output of an expression being used as input for the next expression.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>any arguments passed.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>any key-word arguments passed</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Expression, Any]</code> <p>the computed output of this pipeline or a partial expression if the args and kwargs provided             are less than expected.</p> Source code in <code>funml/types.py</code> <pre><code>async def __call__(self, *args: Any, **kwargs: Any) -&gt; Union[\"Expression\", Any]:\n\"\"\"Computes the logic within the pipeline and returns the value.\n    This method runs all those expressions in the queue sequentially,\n    with the output of an expression being used as\n    input for the next expression.\n    Args:\n        args: any arguments passed.\n        kwargs: any key-word arguments passed\n    Returns:\n        the computed output of this pipeline or a partial expression if the args and kwargs provided \\\n        are less than expected.\n    \"\"\"\noutput = None\nqueue = self._queue[:-1] if self._is_terminated else self._queue\nfor expn in queue:\nif output is None:\noutput = expn(*args, **kwargs)\nelif isinstance(output, Awaitable):\noutput = expn((await output), **kwargs)\nelse:\noutput = expn(output, **kwargs)\nreturn output\n</code></pre>"},{"location":"reference/#funml.types.Expression","title":"<code>Expression</code>","text":"<p>Logic that returns a value when applied.</p> <p>This is the basic building block of all functions and thus almost everything in FunML is converted into an expression at one point or another.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Optional[Operation]</code> <p>the operation or logic to run as part of this expression</p> <code>None</code> Source code in <code>funml/types.py</code> <pre><code>class Expression:\n\"\"\"Logic that returns a value when applied.\n    This is the basic building block of all functions and thus\n    almost everything in FunML is converted into an expression at one point or another.\n    Args:\n        f: the operation or logic to run as part of this expression\n    \"\"\"\ndef __init__(self, f: Optional[\"Operation\"] = None):\nself._f = f if f is not None else Operation(lambda x, *args, **kwargs: x)\ndef __call__(self, *args: Any, **kwargs: Any) -&gt; Union[\"Expression\", Any]:\n\"\"\"Computes the logic within and returns the value.\n        Args:\n            args: any arguments passed.\n            kwargs: any key-word arguments passed\n        Returns:\n            the computed output of this expression or another expression with a partial operation \\\n            in it if the args provided are less than expected.\n        \"\"\"\nvalue = self._f(*args, **kwargs)\nif isinstance(value, Operation):\nreturn Expression(f=value)\nreturn value\ndef __rshift__(\nself,\nnxt: Union[\n\"Expression\",\n\"Pipeline\",\nCallable,\n],\n) -&gt; Union[\"Pipeline\", Any]:\n\"\"\"This makes piping using the '&gt;&gt;' symbol possible.\n        Combines with the given `nxt` expression or pipeline to produce a new pipeline\n        where data flows from current to nxt.\n        Args:\n            nxt: the next expression, pipeline, or callable to apply after the current one.\n        Returns:\n            a new pipeline  where the first expression is the current expression followed by `nxt` \\\n            or returns the value when the pipeline is executed in case `nxt` is of type `ExecutionExpression`\n        \"\"\"\nnew_pipeline = Pipeline()\nnew_pipeline &gt;&gt; self &gt;&gt; nxt\nreturn new_pipeline\n</code></pre>"},{"location":"reference/#funml.types.Expression.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Computes the logic within and returns the value.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>any arguments passed.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>any key-word arguments passed</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Expression, Any]</code> <p>the computed output of this expression or another expression with a partial operation             in it if the args provided are less than expected.</p> Source code in <code>funml/types.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; Union[\"Expression\", Any]:\n\"\"\"Computes the logic within and returns the value.\n    Args:\n        args: any arguments passed.\n        kwargs: any key-word arguments passed\n    Returns:\n        the computed output of this expression or another expression with a partial operation \\\n        in it if the args provided are less than expected.\n    \"\"\"\nvalue = self._f(*args, **kwargs)\nif isinstance(value, Operation):\nreturn Expression(f=value)\nreturn value\n</code></pre>"},{"location":"reference/#funml.types.Expression.__rshift__","title":"<code>__rshift__(nxt)</code>","text":"<p>This makes piping using the '&gt;&gt;' symbol possible.</p> <p>Combines with the given <code>nxt</code> expression or pipeline to produce a new pipeline where data flows from current to nxt.</p> <p>Parameters:</p> Name Type Description Default <code>nxt</code> <code>Union[Expression, Pipeline, Callable]</code> <p>the next expression, pipeline, or callable to apply after the current one.</p> required <p>Returns:</p> Type Description <code>Union[Pipeline, Any]</code> <p>a new pipeline  where the first expression is the current expression followed by <code>nxt</code>             or returns the value when the pipeline is executed in case <code>nxt</code> is of type <code>ExecutionExpression</code></p> Source code in <code>funml/types.py</code> <pre><code>def __rshift__(\nself,\nnxt: Union[\n\"Expression\",\n\"Pipeline\",\nCallable,\n],\n) -&gt; Union[\"Pipeline\", Any]:\n\"\"\"This makes piping using the '&gt;&gt;' symbol possible.\n    Combines with the given `nxt` expression or pipeline to produce a new pipeline\n    where data flows from current to nxt.\n    Args:\n        nxt: the next expression, pipeline, or callable to apply after the current one.\n    Returns:\n        a new pipeline  where the first expression is the current expression followed by `nxt` \\\n        or returns the value when the pipeline is executed in case `nxt` is of type `ExecutionExpression`\n    \"\"\"\nnew_pipeline = Pipeline()\nnew_pipeline &gt;&gt; self &gt;&gt; nxt\nreturn new_pipeline\n</code></pre>"},{"location":"reference/#funml.types.ExecutionExpression","title":"<code>ExecutionExpression</code>","text":"<p>         Bases: <code>Expression</code></p> <p>Expression that executes all previous once it is found on a pipeline</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>when <code>&gt;&gt;</code> is used after it.</p> Source code in <code>funml/types.py</code> <pre><code>class ExecutionExpression(Expression):\n\"\"\"Expression that executes all previous once it is found on a pipeline\n    Raises:\n        NotImplementedError: when `&gt;&gt;` is used after it.\n    \"\"\"\ndef __rshift__(self, nxt: Any):\n\"\"\"rshift is not supported for this.\n        This is a terminal expression that expects no other expression\n        after it on the pipeline.\n        \"\"\"\nraise NotImplementedError(\"terminal pipeline expression: `&gt;&gt;` not supported\")\n</code></pre>"},{"location":"reference/#funml.types.ExecutionExpression.__rshift__","title":"<code>__rshift__(nxt)</code>","text":"<p>rshift is not supported for this.</p> <p>This is a terminal expression that expects no other expression after it on the pipeline.</p> Source code in <code>funml/types.py</code> <pre><code>def __rshift__(self, nxt: Any):\n\"\"\"rshift is not supported for this.\n    This is a terminal expression that expects no other expression\n    after it on the pipeline.\n    \"\"\"\nraise NotImplementedError(\"terminal pipeline expression: `&gt;&gt;` not supported\")\n</code></pre>"},{"location":"reference/#funml.types.MatchExpression","title":"<code>MatchExpression</code>","text":"<p>         Bases: <code>Expression</code></p> <p>A special expression used when pattern matching.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>Optional[Any]</code> <p>the value to be pattern matched.</p> <code>None</code> Source code in <code>funml/types.py</code> <pre><code>class MatchExpression(Expression):\n\"\"\"A special expression used when pattern matching.\n    Args:\n        arg: the value to be pattern matched.\n    \"\"\"\ndef __init__(self, arg: Optional[Any] = None):\nsuper().__init__()\nself._matches: List[Tuple[Callable[[Any], bool], Expression[T]]] = []\nself.__arg = arg\ndef case(self, pattern: Union[MLType, Any], do: Callable) -&gt; \"MatchExpression\":\n\"\"\"Adds a case to a match statement.\n        This is chainable, allowing multiple cases to be added to the same\n        match pipeline.\n        Args:\n            pattern: the pattern to match against.\n            do: the logic to run if pattern is matched.\n        Returns:\n            The current match expressions, after adding the case.\n        \"\"\"\nif isinstance(pattern, MLType):\ncheck, expn = pattern.generate_case(Operation(func=do))\nelse:\ncheck = lambda arg: is_equal_or_of_type(arg, pattern)\nexpn = Expression(Operation(func=do))\nself.__add_match(check=check, expn=expn)\nreturn self\ndef __add_match(self, check: Callable[[Any], bool], expn: \"Expression\"):\n\"\"\"Adds a match set to the list of match sets\n        A match set comprises a checker function and an expression.\n        The checker function checks if a given argument matches this case.\n        The expression is called when the case is matched.\n        Args:\n            check: the checker function\n            expn: the expression to run if a value matches.\n        \"\"\"\nif not callable(check):\nraise TypeError(f\"the check is supposed to be a callable. Got {check}\")\nif not isinstance(expn, Expression):\nraise TypeError(\nf\"expected expression to be an Expression. Got {type(expn)}\"\n)\nself._matches.append((check, expn))\ndef __call__(self, arg: Optional[Any] = None) -&gt; Union[\"Expression\", Any]:\n\"\"\"Applies the matched case and returns the output.\n        The match cases are surveyed for any that matches the given argument\n        until one that matches is found.\n        Then the expression of that case is run and its output returned.\n        Args:\n            arg: the potential value to match against.\n        Returns:\n            The output of the expression of the matched case.\n        Raises:\n            MatchError: no case was matched for the given argument.\n        \"\"\"\nif arg is None:\narg = self.__arg\nfor check, expn in self._matches:\nif check(arg):\nreturn expn(arg)\nraise errors.MatchError(arg)\n</code></pre>"},{"location":"reference/#funml.types.MatchExpression.__add_match","title":"<code>__add_match(check, expn)</code>","text":"<p>Adds a match set to the list of match sets</p> <p>A match set comprises a checker function and an expression. The checker function checks if a given argument matches this case. The expression is called when the case is matched.</p> <p>Parameters:</p> Name Type Description Default <code>check</code> <code>Callable[[Any], bool]</code> <p>the checker function</p> required <code>expn</code> <code>Expression</code> <p>the expression to run if a value matches.</p> required Source code in <code>funml/types.py</code> <pre><code>def __add_match(self, check: Callable[[Any], bool], expn: \"Expression\"):\n\"\"\"Adds a match set to the list of match sets\n    A match set comprises a checker function and an expression.\n    The checker function checks if a given argument matches this case.\n    The expression is called when the case is matched.\n    Args:\n        check: the checker function\n        expn: the expression to run if a value matches.\n    \"\"\"\nif not callable(check):\nraise TypeError(f\"the check is supposed to be a callable. Got {check}\")\nif not isinstance(expn, Expression):\nraise TypeError(\nf\"expected expression to be an Expression. Got {type(expn)}\"\n)\nself._matches.append((check, expn))\n</code></pre>"},{"location":"reference/#funml.types.MatchExpression.__call__","title":"<code>__call__(arg=None)</code>","text":"<p>Applies the matched case and returns the output.</p> <p>The match cases are surveyed for any that matches the given argument until one that matches is found. Then the expression of that case is run and its output returned.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>Optional[Any]</code> <p>the potential value to match against.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Expression, Any]</code> <p>The output of the expression of the matched case.</p> <p>Raises:</p> Type Description <code>MatchError</code> <p>no case was matched for the given argument.</p> Source code in <code>funml/types.py</code> <pre><code>def __call__(self, arg: Optional[Any] = None) -&gt; Union[\"Expression\", Any]:\n\"\"\"Applies the matched case and returns the output.\n    The match cases are surveyed for any that matches the given argument\n    until one that matches is found.\n    Then the expression of that case is run and its output returned.\n    Args:\n        arg: the potential value to match against.\n    Returns:\n        The output of the expression of the matched case.\n    Raises:\n        MatchError: no case was matched for the given argument.\n    \"\"\"\nif arg is None:\narg = self.__arg\nfor check, expn in self._matches:\nif check(arg):\nreturn expn(arg)\nraise errors.MatchError(arg)\n</code></pre>"},{"location":"reference/#funml.types.MatchExpression.case","title":"<code>case(pattern, do)</code>","text":"<p>Adds a case to a match statement.</p> <p>This is chainable, allowing multiple cases to be added to the same match pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>Union[MLType, Any]</code> <p>the pattern to match against.</p> required <code>do</code> <code>Callable</code> <p>the logic to run if pattern is matched.</p> required <p>Returns:</p> Type Description <code>MatchExpression</code> <p>The current match expressions, after adding the case.</p> Source code in <code>funml/types.py</code> <pre><code>def case(self, pattern: Union[MLType, Any], do: Callable) -&gt; \"MatchExpression\":\n\"\"\"Adds a case to a match statement.\n    This is chainable, allowing multiple cases to be added to the same\n    match pipeline.\n    Args:\n        pattern: the pattern to match against.\n        do: the logic to run if pattern is matched.\n    Returns:\n        The current match expressions, after adding the case.\n    \"\"\"\nif isinstance(pattern, MLType):\ncheck, expn = pattern.generate_case(Operation(func=do))\nelse:\ncheck = lambda arg: is_equal_or_of_type(arg, pattern)\nexpn = Expression(Operation(func=do))\nself.__add_match(check=check, expn=expn)\nreturn self\n</code></pre>"},{"location":"reference/#funml.types.MLType","title":"<code>MLType</code>","text":"<p>An ML-enabled type, that can easily be used in pattern matching, piping etc.</p> <p>Methods common to ML-enabled types are defined in this class.</p> Source code in <code>funml/types.py</code> <pre><code>class MLType:\n\"\"\"An ML-enabled type, that can easily be used in pattern matching, piping etc.\n    Methods common to ML-enabled types are defined in this class.\n    \"\"\"\ndef generate_case(\nself, do: \"Operation\"\n) -&gt; Tuple[Callable[[Any], bool], \"Expression\"]:\n\"\"\"Generates a case statement for pattern matching.\n        Args:\n            do: The operation to do if the arg matches on this type\n        Returns:\n            A tuple (checker, expn) where checker is a function that checks if argument matches this case, and expn \\\n            is the expression that is called when the case is matched.\n        \"\"\"\nraise NotImplemented(\"generate_case not implemented\")\ndef _is_like(self, other: Any) -&gt; bool:\n\"\"\"Checks whether a value has the given pattern.\n        Args:\n            other: the value being checked against the pattern represented by type.\n        Returns:\n            A boolean showing true if `other` matches the pattern represented by current type.\n        \"\"\"\nraise NotImplemented(\"_is_like not implemented\")\n</code></pre>"},{"location":"reference/#funml.types.MLType.generate_case","title":"<code>generate_case(do)</code>","text":"<p>Generates a case statement for pattern matching.</p> <p>Parameters:</p> Name Type Description Default <code>do</code> <code>Operation</code> <p>The operation to do if the arg matches on this type</p> required <p>Returns:</p> Type Description <code>Tuple[Callable[[Any], bool], Expression]</code> <p>A tuple (checker, expn) where checker is a function that checks if argument matches this case, and expn             is the expression that is called when the case is matched.</p> Source code in <code>funml/types.py</code> <pre><code>def generate_case(\nself, do: \"Operation\"\n) -&gt; Tuple[Callable[[Any], bool], \"Expression\"]:\n\"\"\"Generates a case statement for pattern matching.\n    Args:\n        do: The operation to do if the arg matches on this type\n    Returns:\n        A tuple (checker, expn) where checker is a function that checks if argument matches this case, and expn \\\n        is the expression that is called when the case is matched.\n    \"\"\"\nraise NotImplemented(\"generate_case not implemented\")\n</code></pre>"},{"location":"reference/#funml.types.Operation","title":"<code>Operation</code>","text":"<p>A computation.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the logic to run as part of the operation.</p> required Source code in <code>funml/types.py</code> <pre><code>class Operation:\n\"\"\"A computation.\n    Args:\n        func: the logic to run as part of the operation.\n    \"\"\"\ndef __init__(self, func: Callable):\nself.__signature = _get_func_signature(func)\nself.__args_length = _get_non_variable_args_length(self.__signature)\nif len(self.__signature.parameters) == 0:\n# be more fault tolerant by using variable params\nself.__f = lambda *args, **kwargs: func()\nelse:\nself.__f = func\ndef __call__(self, *args: Any, **kwargs: Any) -&gt; Union[\"Operation\", Any]:\n\"\"\"Applies the logic attached to this operation and returns output.\n        Args:\n            args: the args passed\n            kwargs: the context in which the operation is being run.\n        Returns:\n            the final output of the operation's logic code or a partial operation if the args and kwargs \\\n            provided are less than those expected.\n        \"\"\"\ntry:\nargs_length = _get_num_of_relevant_args(self.__signature, *args, **kwargs)\nif args_length &lt; self.__args_length:\nreturn Operation(func=functools.partial(self.__f, *args, **kwargs))\nexcept TypeError:\n# binding is impossible so just use the default implementation\npass\nreturn self.__f(*args, **kwargs)\n</code></pre>"},{"location":"reference/#funml.types.Operation.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Applies the logic attached to this operation and returns output.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>the args passed</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>the context in which the operation is being run.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Operation, Any]</code> <p>the final output of the operation's logic code or a partial operation if the args and kwargs             provided are less than those expected.</p> Source code in <code>funml/types.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; Union[\"Operation\", Any]:\n\"\"\"Applies the logic attached to this operation and returns output.\n    Args:\n        args: the args passed\n        kwargs: the context in which the operation is being run.\n    Returns:\n        the final output of the operation's logic code or a partial operation if the args and kwargs \\\n        provided are less than those expected.\n    \"\"\"\ntry:\nargs_length = _get_num_of_relevant_args(self.__signature, *args, **kwargs)\nif args_length &lt; self.__args_length:\nreturn Operation(func=functools.partial(self.__f, *args, **kwargs))\nexcept TypeError:\n# binding is impossible so just use the default implementation\npass\nreturn self.__f(*args, **kwargs)\n</code></pre>"},{"location":"reference/#errors","title":"Errors","text":"<p>Errors for this domain</p>"},{"location":"reference/#funml.errors.MatchError","title":"<code>MatchError</code>","text":"<p>         Bases: <code>BaseException</code></p> <p>Exception returned when a match fails to find an appropriate case for argument.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>str</code> <p>the argument whose match was not found</p> required Source code in <code>funml/errors.py</code> <pre><code>class MatchError(BaseException):\n\"\"\"Exception returned when a match fails to find an appropriate case for argument.\n    Args:\n        arg: the argument whose match was not found\n    \"\"\"\ndef __init__(self, arg: str):\nself.arg = arg\ndef __repr__(self):\nreturn f\"MatchError: No match found for {self.arg}\"\n</code></pre>"},{"location":"tutorial/","title":"Getting Started","text":"<p>In this tutorial, we will build a simple script that showcases most of the features of FunML.</p>"},{"location":"tutorial/#create-the-script-file","title":"Create the Script File","text":"<p>Create a file <code>main.py</code>.</p> <pre><code>$ touch main.py\n</code></pre>"},{"location":"tutorial/#add-some-custom-data-types","title":"Add Some Custom Data Types","text":"<p>FunML allows us to create two types of custom data types:</p> <ul> <li>Enums: by subclassing the <code>ml.Enum</code> class</li> <li>Records: by wrapping dataclass-like classes with the <code>@record</code> decorator</li> </ul> <p>Note</p> <p>We have shortened <code>funml</code> to <code>ml</code> so wherever you see <code>ml</code> take it as <code>funml</code></p> <p>Add the following code to <code>main.py</code>.</p> <pre><code>from copy import copy\nfrom datetime import date\nimport funml as ml\nclass Date(ml.Enum):\nJanuary = date\nFebruary = date\nMarch = date\nApril = date\nMay = date\nJune = date\nJuly = date\nAugust = date\nSeptember = date\nOctober = date\nNovember = date\nDecember = date\n@ml.record\nclass Color:\nr: int\ng: int\nb: int\na: int = 1\n</code></pre>"},{"location":"tutorial/#expressions","title":"Expressions","text":"<p>The main construct in FunML is the expression. As long as anything is an expression, it can initialize a pipeline i.e. added to the beginning of a pipeline.</p> <p>Anything can be turned into an expression using <code>ml.val</code>. Functions, static values, variables, name it.</p> <p>Expressions are the building blocks for more expressions. Combining multiple expressions creates new expressions</p> <p>An expression can contain:</p> <ul> <li><code>ml.Result</code>, <code>ml.Option</code> and their helpers like <code>ml.is_ok</code>, <code>ml.if_ok</code></li> <li><code>IList</code> and its helpers <code>ireduce</code>, <code>imap</code>, <code>ifilter</code> etc.</li> <li><code>Enum</code>'s, <code>Record</code>'s</li> <li>pattern matching with <code>ml.match().case(...)</code></li> <li>lambda functions wrapped in <code>ml.val</code> to make them expressions</li> <li>Even piping with the <code>&gt;&gt;</code> to move data from LEFT to RIGHT through a number of expressions etc.</li> </ul>"},{"location":"tutorial/#add-some-primitive-expressions","title":"Add Some Primitive Expressions","text":"<p>We can start with a few primitive expressions. These we will use later to build more complex expressions.</p> <p>A typical primitive expression is <code>ml.val(&lt;lambda function&gt;)</code> But one can also wrap functions/classes from external modules</p> <p>e.g. </p> <pre><code>MlDbConnection = ml.val(DbConnection)\n# then later, use it as though it was a funml expression.\nconn = (\nml.val(config) \n&gt;&gt; MlDbConnection\n&gt;&gt; ml.execute())\n</code></pre> <p>We have some builtin primitive expressions like</p> <ul> <li><code>ml.val</code></li> <li><code>ml.match</code></li> <li><code>ml.execute</code></li> <li><code>ml.ireduce</code></li> <li><code>ml.ifilter</code></li> <li><code>ml.imap</code></li> <li><code>ml.if_ok</code></li> <li><code>ml.is_ok</code></li> <li><code>ml.if_err</code></li> <li><code>ml.is_err</code></li> <li><code>ml.if_some</code></li> <li><code>ml.is_some</code></li> <li><code>ml.if_none</code></li> <li><code>ml.is_none</code></li> <li><code>ml.to_dict</code></li> <li><code>ml.to_json</code></li> <li><code>ml.from_json</code></li> </ul> <p>So in our script, let's add a <code>main</code> function and in it, add the primitive expressions:</p> <pre><code>def main():\n\"\"\"Main program\"\"\"\n\"\"\"\n    Primitive Expressions\n    \"\"\"\nunit = ml.val(lambda v: v)\nis_even = ml.val(lambda v: v % 2 == 0)\nmul = ml.val(lambda args: args[0] * args[1])\nsuperscript = ml.val(lambda num, power=1: num**power)\nget_month = ml.val(lambda value: value.month)\nis_num = ml.val(lambda v: isinstance(v, (int, float)))\nis_exp = ml.val(lambda v: isinstance(v, BaseException))\nif_else = lambda check=unit, do=unit, else_do=unit: ml.val(\nlambda *args, **kwargs: (\nml.match(check(*args, **kwargs))\n.case(True, do=lambda: do(*args, **kwargs))\n.case(False, do=lambda: else_do(*args, **kwargs))\n)()\n)\n</code></pre>"},{"location":"tutorial/#compose-some-high-order-expressions","title":"Compose Some High Order Expressions","text":"<p>Here we combine the primitive expressions into more complex ones using:</p> <ul> <li>normal function calls e.g. <code>if_else(some_stuff)</code> where <code>if_else</code> is a primitive expression</li> <li>a form of currying e.g. <code>add3 = add(3)</code> where <code>add = lambda x, y: x+y</code></li> <li>pipelines using the pipeline operator (<code>&gt;&gt;</code>).   Pipelines let one start with data followed by the steps that operate on that   data e.g. <code>output = records &gt;&gt; remove_nulls &gt;&gt; parse_json &gt;&gt; ml.execute()</code></li> <li>chaining primitives that have methods on their outputs that return expressions.   e.g. <code>output = ml.match(data).case(1, do=...).case(2, do=...).case(3, ...)</code></li> </ul> <p>We can combine these complex expressions into even more complex ones to infinite complexity.</p> <p>Info</p> <p>That is the main thing about functional programming i.e. composing simpler functions into more complex functions  to an indefinite level of complexity BUT while keeping the complex functions readable and predictable (pure).</p> <p>In our <code>main</code> function in our script <code>main.py</code>, let's add the following high order expressions.</p> <pre><code>    \"\"\"\n    High Order Expressions\n    \"\"\"\nfactorial = lambda v, accum=1: (\nml.match(v &lt;= 0)\n.case(True, do=ml.val(accum))\n.case(False, do=lambda num, ac=0: factorial(num - 1, accum=num * ac)())\n)\n# currying expressions is possible\ncube = superscript(power=3)\nget_item_types = ml.ireduce(lambda x, y: f\"{type(x)}, {type(y)}\")\nnums_type_err = ml.val(\nlambda args: TypeError(f\"expected numbers, got {get_item_types(args)}\")\n)\nis_seq_of_nums = ml.ireduce(lambda x, y: x and is_num(y), True)\nto_result = ml.val(lambda v: ml.Result.ERR(v) if is_exp(v) else ml.Result.OK(v))\ntry_multiply = (\nif_else(check=is_seq_of_nums, do=mul, else_do=nums_type_err) &gt;&gt; to_result\n)\nresult_to_option = ml.if_ok(ml.Option.SOME, strict=False) &gt;&gt; ml.if_err(\nlambda *args: ml.Option.NONE, strict=False\n)\nto_date_enum = ml.val(\nlambda v: (\nml.match(v.month)\n.case(1, do=ml.val(Date.January(v)))\n.case(2, do=ml.val(Date.February(v)))\n.case(3, do=ml.val(Date.March(v)))\n.case(4, do=ml.val(Date.April(v)))\n.case(5, do=ml.val(Date.May(v)))\n.case(6, do=ml.val(Date.June(v)))\n.case(7, do=ml.val(Date.July(v)))\n.case(8, do=ml.val(Date.August(v)))\n.case(9, do=ml.val(Date.September(v)))\n.case(10, do=ml.val(Date.October(v)))\n.case(11, do=ml.val(Date.November(v)))\n.case(12, do=ml.val(Date.December(v)))\n)()\n)\nget_month_str = get_month &gt;&gt; (\nml.match()\n.case(1, do=ml.val(\"JAN\"))\n.case(2, do=ml.val(\"FEB\"))\n.case(3, do=ml.val(\"MAR\"))\n.case(4, do=ml.val(\"APR\"))\n.case(5, do=ml.val(\"MAY\"))\n.case(6, do=ml.val(\"JUN\"))\n.case(7, do=ml.val(\"JUL\"))\n.case(8, do=ml.val(\"AUG\"))\n.case(9, do=ml.val(\"SEP\"))\n.case(10, do=ml.val(\"OCT\"))\n.case(11, do=ml.val(\"NOV\"))\n.case(12, do=ml.val(\"DEC\"))\n)\n</code></pre>"},{"location":"tutorial/#add-the-data-to-work-on","title":"Add the Data to Work On","text":"<p>We have a number of data types that are work well with FunML</p> <ul> <li>IList: an immutable list, with pattern matching enabled </li> <li>Enum: an enumerable data type, with pattern matching enabled</li> <li>Record: a record-like data type, with pattern matching enabled</li> </ul> <p>Using our High order expressions (and primitive ones, your choice), we operate on the data.</p> <p>In order to add data variables to pipelines, we turn them into expressions using <code>ml.val</code> e.g. <code>ml.val(90)</code> becomes an expression that evaluates to <code>lambda: 90</code>.</p> <p>Remember, when evaluating pipelines, we start with the data, then the steps of transformation it has to go through.</p> <p>Let's add some data to the <code>main</code> function in our script <code>main.py</code>.</p> <pre><code>    \"\"\"\n    Data\n    \"\"\"\ndates = [\ndate(200, 3, 4),\ndate(2009, 1, 16),\ndate(1993, 12, 29),\ndate(2004, 10, 13),\ndate(2020, 9, 5),\ndate(2004, 5, 7),\ndate(1228, 8, 18),\n]\ndates = ml.val(dates)\nnums = ml.val(ml.l(12, 3, 45, 7, 8, 6, 3))\ndata = ml.l((2, 3), (\"hey\", 7), (5, \"y\"), (8.1, 6))\nblue = Color(r=0, g=0, b=255)\n</code></pre>"},{"location":"tutorial/#create-some-pipelines-and-execute-them","title":"Create Some Pipelines and Execute Them","text":"<p>To construct pipelines, we use <code>&gt;&gt;</code> starting with an expression or data wrapped in <code>ml.val</code>.</p> <p>Note</p> <p>If we don't add data before the pipeline, we will have to add it in another step later.</p> <p>Info</p> <p>We prefer putting data before transformations in pipelines because it is more readable (usually).</p> <p>However, you might discover that it is also possible to save a pipeline and invoke it on the data like a normal function.</p> <p>Try not to do that.</p> <p>Pipelines move data from left to right, transforming it from one step to the next.</p> <p>Pipelines are lazily evaluated. To evaluate/execute a pipeline, we add <code>ml.execute()</code> as the last step of the pipeline. This transforms the inputs into some output and returns the output.</p> <p>Otherwise, we can keep adding steps to such a pipeline across different sections of the code.</p> <p>Alright, let's create and evaluate some pipelines.</p> <pre><code>    dates_as_enums = dates &gt;&gt; ml.imap(to_date_enum) &gt;&gt; ml.execute()\nprint(f\"\\ndates as enums: {dates_as_enums}\")\nprint(f\"\\nfirst date enum: {dates_as_enums[0]}\")\nmonths_as_str = dates &gt;&gt; ml.imap(get_month_str) &gt;&gt; ml.execute()\nprint(f\"\\nmonths of dates as str:\\n{months_as_str}\")\nprint(f\"\\ncube of 5: {cube(5)}\")\neven_nums_pipeline = nums &gt;&gt; ml.ifilter(is_even)\n# here `even_nums_pipeline` is a `Pipeline` instance\nprint(even_nums_pipeline)\nfactorials_list = (\ncopy(even_nums_pipeline)\n&gt;&gt; ml.imap(lambda v: f\"factorial for {v}: {factorial(v)}\")\n&gt;&gt; ml.execute()\n)\n# we created a new pipeline by coping the previous one\n# otherwise we would be mutating the old pipeline.\n# Calling ml.execute(), we get an actual iterable of strings\nprint(factorials_list)\nfactorials_str = (\neven_nums_pipeline\n&gt;&gt; ml.imap(lambda v: f\"factorial for {v}: {factorial(v)}\")\n&gt;&gt; ml.ireduce(lambda x, y: f\"{x}\\n{y}\")\n&gt;&gt; ml.execute()\n)\n# here after calling ml.execute(), we get one string as output\nprint(factorials_str)\nprint(f\"blue: {blue}\")\ndata = ml.val(data) &gt;&gt; ml.imap(try_multiply) &gt;&gt; ml.execute()\nprint(f\"\\nafter multiplication:\\n{data}\")\ndata_as_options = ml.val(data) &gt;&gt; ml.imap(result_to_option) &gt;&gt; ml.execute()\nprint(f\"\\ndata as options: {data_as_options}\")\ndata_as_actual_values = (\nml.val(data) &gt;&gt; ml.ifilter(ml.is_ok) &gt;&gt; ml.imap(ml.if_ok(unit)) &gt;&gt; ml.execute()\n)\nprint(f\"\\ndata as actual values: {data_as_actual_values}\")\n</code></pre>"},{"location":"tutorial/#run-the-script","title":"Run the Script","text":"<p>To run the <code>main</code> function, we need to add the following code at the end of the <code>main.py</code> script.</p> <pre><code>if __name__ == \"__main__\":\nmain()\n</code></pre> <p>The final script should look like:</p> <pre><code>from copy import copy\nfrom datetime import date\nimport funml as ml\nclass Date(ml.Enum):\nJanuary = date\nFebruary = date\nMarch = date\nApril = date\nMay = date\nJune = date\nJuly = date\nAugust = date\nSeptember = date\nOctober = date\nNovember = date\nDecember = date\n@ml.record\nclass Color:\nr: int\ng: int\nb: int\na: int = 1\ndef main():\n\"\"\"Main program\"\"\"\n\"\"\"\n    Primitive Expressions\n    \"\"\"\nunit = ml.val(lambda v: v)\nis_even = ml.val(lambda v: v % 2 == 0)\nmul = ml.val(lambda args: args[0] * args[1])\nsuperscript = ml.val(lambda num, power=1: num**power)\nget_month = ml.val(lambda value: value.month)\nis_num = ml.val(lambda v: isinstance(v, (int, float)))\nis_exp = ml.val(lambda v: isinstance(v, BaseException))\nif_else = lambda check=unit, do=unit, else_do=unit: ml.val(\nlambda *args, **kwargs: (\nml.match(check(*args, **kwargs))\n.case(True, do=lambda: do(*args, **kwargs))\n.case(False, do=lambda: else_do(*args, **kwargs))\n)()\n)\n\"\"\"\n    High Order Expressions\n    \"\"\"\nfactorial = lambda v, accum=1: (\nml.match(v &lt;= 0)\n.case(True, do=ml.val(accum))\n.case(False, do=lambda num, ac=0: factorial(num - 1, accum=num * ac)())\n)\n# currying expressions is possible\ncube = superscript(power=3)\nget_item_types = ml.ireduce(lambda x, y: f\"{type(x)}, {type(y)}\")\nnums_type_err = ml.val(\nlambda args: TypeError(f\"expected numbers, got {get_item_types(args)}\")\n)\nis_seq_of_nums = ml.ireduce(lambda x, y: x and is_num(y), True)\nto_result = ml.val(lambda v: ml.Result.ERR(v) if is_exp(v) else ml.Result.OK(v))\ntry_multiply = (\nif_else(check=is_seq_of_nums, do=mul, else_do=nums_type_err) &gt;&gt; to_result\n)\nresult_to_option = ml.if_ok(ml.Option.SOME, strict=False) &gt;&gt; ml.if_err(\nlambda *args: ml.Option.NONE, strict=False\n)\nto_date_enum = ml.val(\nlambda v: (\nml.match(v.month)\n.case(1, do=ml.val(Date.January(v)))\n.case(2, do=ml.val(Date.February(v)))\n.case(3, do=ml.val(Date.March(v)))\n.case(4, do=ml.val(Date.April(v)))\n.case(5, do=ml.val(Date.May(v)))\n.case(6, do=ml.val(Date.June(v)))\n.case(7, do=ml.val(Date.July(v)))\n.case(8, do=ml.val(Date.August(v)))\n.case(9, do=ml.val(Date.September(v)))\n.case(10, do=ml.val(Date.October(v)))\n.case(11, do=ml.val(Date.November(v)))\n.case(12, do=ml.val(Date.December(v)))\n)()\n)\nget_month_str = get_month &gt;&gt; (\nml.match()\n.case(1, do=ml.val(\"JAN\"))\n.case(2, do=ml.val(\"FEB\"))\n.case(3, do=ml.val(\"MAR\"))\n.case(4, do=ml.val(\"APR\"))\n.case(5, do=ml.val(\"MAY\"))\n.case(6, do=ml.val(\"JUN\"))\n.case(7, do=ml.val(\"JUL\"))\n.case(8, do=ml.val(\"AUG\"))\n.case(9, do=ml.val(\"SEP\"))\n.case(10, do=ml.val(\"OCT\"))\n.case(11, do=ml.val(\"NOV\"))\n.case(12, do=ml.val(\"DEC\"))\n)\n\"\"\"\n    Data\n    \"\"\"\ndates = [\ndate(200, 3, 4),\ndate(2009, 1, 16),\ndate(1993, 12, 29),\ndate(2004, 10, 13),\ndate(2020, 9, 5),\ndate(2004, 5, 7),\ndate(1228, 8, 18),\n]\ndates = ml.val(dates)\nnums = ml.val(ml.l(12, 3, 45, 7, 8, 6, 3))\ndata = ml.l((2, 3), (\"hey\", 7), (5, \"y\"), (8.1, 6))\nblue = Color(r=0, g=0, b=255)\n\"\"\"\n    Pipeline Creation and Execution\n    \"\"\"\ndates_as_enums = dates &gt;&gt; ml.imap(to_date_enum) &gt;&gt; ml.execute()\nprint(f\"\\ndates as enums: {dates_as_enums}\")\nprint(f\"\\nfirst date enum: {dates_as_enums[0]}\")\nmonths_as_str = dates &gt;&gt; ml.imap(get_month_str) &gt;&gt; ml.execute()\nprint(f\"\\nmonths of dates as str:\\n{months_as_str}\")\nprint(f\"\\ncube of 5: {cube(5)}\")\neven_nums_pipeline = nums &gt;&gt; ml.ifilter(is_even)\n# here `even_nums_pipeline` is a `Pipeline` instance\nprint(even_nums_pipeline)\nfactorials_list = (\ncopy(even_nums_pipeline)\n&gt;&gt; ml.imap(lambda v: f\"factorial for {v}: {factorial(v)}\")\n&gt;&gt; ml.execute()\n)\n# we created a new pipeline by coping the previous one\n# otherwise we would be mutating the old pipeline.\n# Calling ml.execute(), we get an actual iterable of strings\nprint(factorials_list)\nfactorials_str = (\neven_nums_pipeline\n&gt;&gt; ml.imap(lambda v: f\"factorial for {v}: {factorial(v)}\")\n&gt;&gt; ml.ireduce(lambda x, y: f\"{x}\\n{y}\")\n&gt;&gt; ml.execute()\n)\n# here after calling ml.execute(), we get one string as output\nprint(factorials_str)\nprint(f\"blue: {blue}\")\ndata = ml.val(data) &gt;&gt; ml.imap(try_multiply) &gt;&gt; ml.execute()\nprint(f\"\\nafter multiplication:\\n{data}\")\ndata_as_options = ml.val(data) &gt;&gt; ml.imap(result_to_option) &gt;&gt; ml.execute()\nprint(f\"\\ndata as options: {data_as_options}\")\ndata_as_actual_values = (\nml.val(data) &gt;&gt; ml.ifilter(ml.is_ok) &gt;&gt; ml.imap(ml.if_ok(unit)) &gt;&gt; ml.execute()\n)\nprint(f\"\\ndata as actual values: {data_as_actual_values}\")\nif __name__ == \"__main__\":\nmain()\n</code></pre> <p>And then run the script  in the terminal with:</p> <pre><code>$ python main.py\n\ndates as enums: [&amp;lt;Date.March: (datetime.date(200, 3, 4),)&amp;gt;, &amp;lt;Date.January: (datetime.date(2009, 1, 16),)&amp;gt;, &amp;lt;Date.December: (datetime.date(1993, 12, 29),)&amp;gt;, &amp;lt;Date.October: (datetime.date(2004, 10, 13),)&amp;gt;, &amp;lt;Date.September: (datetime.date(2020, 9, 5),)&amp;gt;, &amp;lt;Date.May: (datetime.date(2004, 5, 7),)&amp;gt;, &amp;lt;Date.August: (datetime.date(1228, 8, 18),)&amp;gt;]\nfirst date enum: &amp;lt;Date.March: (datetime.date(200, 3, 4),)&amp;gt;\nmonths of dates as str:\n[MAR, JAN, DEC, OCT, SEP, MAY, AUG]\ncube of 5: 125\n&amp;lt;funml.types.Pipeline object at 0x1039ce690&amp;gt;\n[factorial for 12: 479001600, factorial for 8: 40320, factorial for 6: 720]\nfactorial for 12: 479001600\nfactorial for 8: 40320\nfactorial for 6: 720\nblue: {'a': 1, 'r': 0, 'g': 0, 'b': 255}\nafter multiplication:\n[&amp;lt;Result.OK: 6&amp;gt;, &amp;lt;Result.ERR: TypeError(\"expected numbers, got &amp;lt;class 'str'&amp;gt;, &amp;lt;class 'int'&amp;gt;\")&amp;gt;, &amp;lt;Result.ERR: TypeError(\"expected numbers, got &amp;lt;class 'int'&amp;gt;, &amp;lt;class 'str'&amp;gt;\")&amp;gt;, &amp;lt;Result.OK: 48.599999999999994&amp;gt;]\ndata as options: [&amp;lt;Option.SOME: 6&amp;gt;, &amp;lt;Option.NONE: 'NONE'&amp;gt;, &amp;lt;Option.NONE: 'NONE'&amp;gt;, &amp;lt;Option.SOME: 48.599999999999994&amp;gt;]\ndata as actual values: [6, 48.599999999999994]\n</code></pre>"}]}